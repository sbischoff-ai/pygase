{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyGaSe Py thon Ga me Se rver A package for Python 3.6+ that contains a game-ready client-server architecture and UDP-based network protocol. It deals with problems such as package loss or network congestion so you don't have to. Instead it gives you a high-level API to easily connect clients and backends that share a synchronized game state and exchange events. The async framework for this one is curio , which I highly recommend. PyGaSe is built to be easy to use, lightweight, fast, scalable and reliable. You can build a fast-paced real-time online game with this. You can also build a large-scale MMO with thousands of clients if you like. I'm actively developing PyGaSe in the context of several Indie game projects and I'm happy to share it. BREAKING CHANGE : Version 0.2.0 is basically a new API and updating from 0.1.9 or lower will break you code. It is also much more stable, flexible and powerful, so make sure to use 0.2.0 or higher. Installation pip install pygase or better yet poetry add pygase . Seriously, use poetry , it's a revelation. Usage API Reference & Tutorials For API documentation and a Getting Started section go here . Example This example game implements an online game of tag, in which players can move around, while one of them is the chaser who has to catch another player. A player who has been catched becomes the next chaser and can catch other players after a 5s protection countdown. Run server.py first, then run client.py in additional terminal sessions to add players. Only use the same player name once. Debugging & Logging You can use the standard logging module. On level INFO you will get logging output for events such as startups, shutdowns, new connections or disconnects. On DEBUG level you get detailed output right down to the level of sending, receiving and handling single network packages. Debug logs are also a good way to understand the inner workings of PyGaSe. Changes 0.3.0 sticking to SemVer from here on out logging added using the standard logging module improve event handler arguments Backend class added to reduce server-side boilerplate various bugfixes 0.2.0 complete overhaul of pygase 0.1.x with breaking API changes","title":"Home"},{"location":"#pygase","text":"Py thon Ga me Se rver A package for Python 3.6+ that contains a game-ready client-server architecture and UDP-based network protocol. It deals with problems such as package loss or network congestion so you don't have to. Instead it gives you a high-level API to easily connect clients and backends that share a synchronized game state and exchange events. The async framework for this one is curio , which I highly recommend. PyGaSe is built to be easy to use, lightweight, fast, scalable and reliable. You can build a fast-paced real-time online game with this. You can also build a large-scale MMO with thousands of clients if you like. I'm actively developing PyGaSe in the context of several Indie game projects and I'm happy to share it. BREAKING CHANGE : Version 0.2.0 is basically a new API and updating from 0.1.9 or lower will break you code. It is also much more stable, flexible and powerful, so make sure to use 0.2.0 or higher.","title":"PyGaSe"},{"location":"#installation","text":"pip install pygase or better yet poetry add pygase . Seriously, use poetry , it's a revelation.","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#api-reference-tutorials","text":"For API documentation and a Getting Started section go here .","title":"API Reference &amp; Tutorials"},{"location":"#example","text":"This example game implements an online game of tag, in which players can move around, while one of them is the chaser who has to catch another player. A player who has been catched becomes the next chaser and can catch other players after a 5s protection countdown. Run server.py first, then run client.py in additional terminal sessions to add players. Only use the same player name once.","title":"Example"},{"location":"#debugging-logging","text":"You can use the standard logging module. On level INFO you will get logging output for events such as startups, shutdowns, new connections or disconnects. On DEBUG level you get detailed output right down to the level of sending, receiving and handling single network packages. Debug logs are also a good way to understand the inner workings of PyGaSe.","title":"Debugging &amp; Logging"},{"location":"#changes","text":"","title":"Changes"},{"location":"#030","text":"sticking to SemVer from here on out logging added using the standard logging module improve event handler arguments Backend class added to reduce server-side boilerplate various bugfixes","title":"0.3.0"},{"location":"#020","text":"complete overhaul of pygase 0.1.x with breaking API changes","title":"0.2.0"},{"location":"getting-started/","text":"Getting Started This little starter guide demonstrates the basics of setting up und running a backend, connecting a client and communication via events. Backend To set up a simple PyGaSe backend we will need two classes: from pygase import GameState, Backend First we define our initial game state: # Let there be an imaginary enemy at position 0 with 100 health points. initial_game_state = GameState(position=0.0, hp=100) The GameState constructor uses keyword arguments to initialize game state attributes. (We have to use built-in types such as int , str or dict , so the game state is serializable.) In this case our game state resembles the dict {\"position\": 0.0, \"hp\": 100} at the start of the game. Next we define a time step function for the game loop: import math def time_step(game_state, dt): # Make the imaginary enemy move in sinuous lines like a drunkard. new_position = game_state.position += math.sin(dt) return {\"position\": new_position} The time_step function represents one iteration of the game loop and takes the current game_state as an argument, in order to return a dict containing all the changes to the game state. By default it will be called 50 times per second (or once every 0.02 seconds, respectively). However, the actual interval may turn out somewhat longer and differ from time to time, which is why the time step function also gets the time since the last time step in seconds ( dt ). In this example our game loop will have the enemies position continously oscillating between -1.0 and 1.0. The backend should always have authority over the game logic and be the single point of truth for the shared state. It might however be beneficial to performance and a smooth feel of a game to pre-compute some game logic client-side and only validate it in the backend. Now we can initialize and run the backend: backend = Backend(initial_game_state, time_step) backend.run('localhost', 8080) Mind that this run call is blocking, so whatever we put after there will not be executed until the backend is shut down again. Put all together, our first super simple PyGaSe backend looks like this: # backend.py import math from pygase import GameState, Backend # Let there be an imaginary enemy at position 0 with 100 health points. initial_game_state = GameState(position=0, hp=100) def time_step(game_state, dt): # Make the imaginary enemy move in sinuous lines like a drunkard. new_position = game_state.position += math.sin(dt) return {\"position\": new_position} backend = Backend(initial_game_state, time_step) backend.run('localhost', 8080) Client If we run python backend.py it starts a server that just sits there until we terminate the python process. To interact with it we could connect a client in an interactive python session in another console window: >>> from pygase import Client >>> client = Client() >>> client.connect_in_thread(port=8080) # hostname=\"localhost\" is default <Thread(Thread-1, started 24096)> # returns the corresponding thread >>> with client.access_game_state() as game_state: ... print(game_state.position) ... print(game_state.hp) ... 0.7904802223420048 100 >>> with client.access_game_state() as game_state: ... print(game_state.position) ... -0.29265129683264307 >>> We have to connect in a thread here, because a blocking Client.connect() call would have made it impossible to interact with the client in the same terminal session. We have to access the game state in a with block like this to ensure that the client is not updating it as we use it. But we also have to be careful not to leave this with block unterminated indefinitely, which would block the client from synchronizing the game state. However, reading only is a rather one-sided kind of interaction. To have the client talk to the backend we will use events. Events First we need to register an event handler on the backend side or the event will do nothing: # A client might choose to attack the drunken master. def on_attack(attack_position, game_state, **kwargs): # Check if the attack landed near enough to hit. if abs(attack_position - game_state.position) < 0.1: print(\"Hit!\") # Subtract the attacks damage from the enemies health. return {\"hp\": game_state.hp - 10} print(\"Missed.\") return {} backend = Backend( initial_game_state, time_step, event_handlers={\"ATTACK\": on_attack} ) backend.run('localhost', 8080) The event handler function on_attack works similar to the time step function, only that it receives additional keyword arguments like the current game_state in this case or the attack_position , which we assume to be attached to the event by the client. Having extended the backend like this we can now restart it and try out the event in a client terminal session: >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> with client.access_game_state() as game_state: ... print(game_state.position) ... print(game_state.hp) # Check if we hit. ... -0.1760756199485871 100 >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> with client.access_game_state() as game_state: ... print(game_state.hp) # Check again ... ... 100 >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> with client.access_game_state() as game_state: ... print(game_state.hp) # ... and again. ... 90 >>> This is me trying repeadedly to land a hit on position 0.5. If you look at the console output of the backend process, you might see something like this: Missed. Missed. Hit! Missed. It's not very practical to have to switch the console windows, it would be better if the client received some feedback after an attack. Events can also flow from backend to client, which works pretty much the same way as the other way around. First we adjust the backends attack event handler to send back a feedback event: backend = Backend(initial_game_state, time_step) # A client might choose to attack the drunken master. def on_attack(attack_position, client_address, game_state, **kwargs): # Check if the attack landed near enough to hit. if abs(attack_position - game_state.position) < 0.1: backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Hit!\", target_client=client_address) # Subtract the attacks damage from the enemies health. return {\"hp\": game_state.hp - 10} backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Missed.\", target_client=client_address) return {} backend.game_state_machine.register_event_handler(\"ATTACK\", on_attack) backend.run('localhost', 8080) Here we used another one of the keyword arguments PyGaSe passes to the event handler, the client_address from which the event was sent. Along with the event data, a string containing the feedback message, we also set the target client for our event. The default for target_client is \"all\" which broadcasts the event. As you can see, the dispatch_event method we used is not a member of backend but of backend.server and register_event_handler is a member of backend.game_state_machine . In fact, a PyGaSe backend consists of three main components: - A Server that deals with connected clients. - A GameStateStore which is where the backend keeps track of the state. - A GameStateMachine that runs the whole game logic simulation and produces state updates. Now we only need to register an appropriate event handler on the client side: >>> client.register_event_handler(\"ATTACK_FEEDBACK\", print) >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) Missed. >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) Missed. >>> for i in range(5): ... client.dispatch_event(\"ATTACK\", attack_position=i*2.0/5-1) ... Missed. Hit! Missed. Missed. Missed. Much better. We get direct feedback and even found an exploit that allows us to land a guaranteed hit by using a for loop. Registering the built-in function print as the event handler callback works in this case, because the handler only receives one argument: the string that the backend attached to the event in backend.server.dispatch_event() . A proper client for this game, with a UI and everything, would probably not allow to send attack events in such a way. Still, this is how cheats and hacks find their way into an online game, which is why the backend should validate some of the events it gets. In this case for example, it might check if ATTACK events are coming in at an unreasonably high frequency. Conclusion Up to now we had to nastily interrupt the backend process and the client thread by hand in order to end a session. Of course we can also properly terminate everything, for example with >>> client.disconnect(shutdown_server=True) in the client terminal session. Only the first player to connect will have the permission to shutdown the server like this. The backend can also shut itself down with backend.shutdown() . To conclude the conclusion: We have set up a small PyGaSe backend that simulates a moving enemy and handles attack events. Right now, the enemy would never die and its hp would just go into the negative numbers after you hit zero. So good next steps might be to implement a way for this game to end by defeating the drunken master or maybe have the enemy defend itself. Also, a graphical UI wouldn't hurt (I recommend the awesome Arcade library for this). To see how this might be done with PyGaSe you can look through the API reference here or you can take a peek into this little example game of tag , which uses PyGaSe and pygame . For the sake of completeness: # backend.py import math from pygase import GameState, Backend ### SETUP ### # Let there be an imaginary enemy at position 0 with 100 health points. initial_game_state = GameState(position=0, hp=100) # Define what happens in an iteration of the game loop. def time_step(game_state, dt): # Make the imaginary enemy move in sinuous lines like a drunkard. new_position = game_state.position += math.sin(dt) return {\"position\": new_position} # Create the backend. backend = Backend(initial_game_state, time_step) ### EVENT HANDLERS ### def on_attack(attack_position, client_address, game_state, **kwargs): # Check if the attack landed near enough to hit. if abs(attack_position - game_state.position) < 0.1: backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Hit!\", target_client=client_address) # Subtract the attacks damage from the enemies health. return {\"hp\": game_state.hp - 10} backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Missed.\", target_client=client_address) return {} backend.game_state_machine.register_event_handler(\"ATTACK\", on_attack) ### MAIN PROCESS ### if __name__ == \"__main__\": backend.run('localhost', 8080)","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"This little starter guide demonstrates the basics of setting up und running a backend, connecting a client and communication via events.","title":"Getting Started"},{"location":"getting-started/#backend","text":"To set up a simple PyGaSe backend we will need two classes: from pygase import GameState, Backend First we define our initial game state: # Let there be an imaginary enemy at position 0 with 100 health points. initial_game_state = GameState(position=0.0, hp=100) The GameState constructor uses keyword arguments to initialize game state attributes. (We have to use built-in types such as int , str or dict , so the game state is serializable.) In this case our game state resembles the dict {\"position\": 0.0, \"hp\": 100} at the start of the game. Next we define a time step function for the game loop: import math def time_step(game_state, dt): # Make the imaginary enemy move in sinuous lines like a drunkard. new_position = game_state.position += math.sin(dt) return {\"position\": new_position} The time_step function represents one iteration of the game loop and takes the current game_state as an argument, in order to return a dict containing all the changes to the game state. By default it will be called 50 times per second (or once every 0.02 seconds, respectively). However, the actual interval may turn out somewhat longer and differ from time to time, which is why the time step function also gets the time since the last time step in seconds ( dt ). In this example our game loop will have the enemies position continously oscillating between -1.0 and 1.0. The backend should always have authority over the game logic and be the single point of truth for the shared state. It might however be beneficial to performance and a smooth feel of a game to pre-compute some game logic client-side and only validate it in the backend. Now we can initialize and run the backend: backend = Backend(initial_game_state, time_step) backend.run('localhost', 8080) Mind that this run call is blocking, so whatever we put after there will not be executed until the backend is shut down again. Put all together, our first super simple PyGaSe backend looks like this: # backend.py import math from pygase import GameState, Backend # Let there be an imaginary enemy at position 0 with 100 health points. initial_game_state = GameState(position=0, hp=100) def time_step(game_state, dt): # Make the imaginary enemy move in sinuous lines like a drunkard. new_position = game_state.position += math.sin(dt) return {\"position\": new_position} backend = Backend(initial_game_state, time_step) backend.run('localhost', 8080)","title":"Backend"},{"location":"getting-started/#client","text":"If we run python backend.py it starts a server that just sits there until we terminate the python process. To interact with it we could connect a client in an interactive python session in another console window: >>> from pygase import Client >>> client = Client() >>> client.connect_in_thread(port=8080) # hostname=\"localhost\" is default <Thread(Thread-1, started 24096)> # returns the corresponding thread >>> with client.access_game_state() as game_state: ... print(game_state.position) ... print(game_state.hp) ... 0.7904802223420048 100 >>> with client.access_game_state() as game_state: ... print(game_state.position) ... -0.29265129683264307 >>> We have to connect in a thread here, because a blocking Client.connect() call would have made it impossible to interact with the client in the same terminal session. We have to access the game state in a with block like this to ensure that the client is not updating it as we use it. But we also have to be careful not to leave this with block unterminated indefinitely, which would block the client from synchronizing the game state. However, reading only is a rather one-sided kind of interaction. To have the client talk to the backend we will use events.","title":"Client"},{"location":"getting-started/#events","text":"First we need to register an event handler on the backend side or the event will do nothing: # A client might choose to attack the drunken master. def on_attack(attack_position, game_state, **kwargs): # Check if the attack landed near enough to hit. if abs(attack_position - game_state.position) < 0.1: print(\"Hit!\") # Subtract the attacks damage from the enemies health. return {\"hp\": game_state.hp - 10} print(\"Missed.\") return {} backend = Backend( initial_game_state, time_step, event_handlers={\"ATTACK\": on_attack} ) backend.run('localhost', 8080) The event handler function on_attack works similar to the time step function, only that it receives additional keyword arguments like the current game_state in this case or the attack_position , which we assume to be attached to the event by the client. Having extended the backend like this we can now restart it and try out the event in a client terminal session: >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> with client.access_game_state() as game_state: ... print(game_state.position) ... print(game_state.hp) # Check if we hit. ... -0.1760756199485871 100 >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> with client.access_game_state() as game_state: ... print(game_state.hp) # Check again ... ... 100 >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) >>> with client.access_game_state() as game_state: ... print(game_state.hp) # ... and again. ... 90 >>> This is me trying repeadedly to land a hit on position 0.5. If you look at the console output of the backend process, you might see something like this: Missed. Missed. Hit! Missed. It's not very practical to have to switch the console windows, it would be better if the client received some feedback after an attack. Events can also flow from backend to client, which works pretty much the same way as the other way around. First we adjust the backends attack event handler to send back a feedback event: backend = Backend(initial_game_state, time_step) # A client might choose to attack the drunken master. def on_attack(attack_position, client_address, game_state, **kwargs): # Check if the attack landed near enough to hit. if abs(attack_position - game_state.position) < 0.1: backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Hit!\", target_client=client_address) # Subtract the attacks damage from the enemies health. return {\"hp\": game_state.hp - 10} backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Missed.\", target_client=client_address) return {} backend.game_state_machine.register_event_handler(\"ATTACK\", on_attack) backend.run('localhost', 8080) Here we used another one of the keyword arguments PyGaSe passes to the event handler, the client_address from which the event was sent. Along with the event data, a string containing the feedback message, we also set the target client for our event. The default for target_client is \"all\" which broadcasts the event. As you can see, the dispatch_event method we used is not a member of backend but of backend.server and register_event_handler is a member of backend.game_state_machine . In fact, a PyGaSe backend consists of three main components: - A Server that deals with connected clients. - A GameStateStore which is where the backend keeps track of the state. - A GameStateMachine that runs the whole game logic simulation and produces state updates. Now we only need to register an appropriate event handler on the client side: >>> client.register_event_handler(\"ATTACK_FEEDBACK\", print) >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) Missed. >>> client.dispatch_event(\"ATTACK\", attack_position=0.5) Missed. >>> for i in range(5): ... client.dispatch_event(\"ATTACK\", attack_position=i*2.0/5-1) ... Missed. Hit! Missed. Missed. Missed. Much better. We get direct feedback and even found an exploit that allows us to land a guaranteed hit by using a for loop. Registering the built-in function print as the event handler callback works in this case, because the handler only receives one argument: the string that the backend attached to the event in backend.server.dispatch_event() . A proper client for this game, with a UI and everything, would probably not allow to send attack events in such a way. Still, this is how cheats and hacks find their way into an online game, which is why the backend should validate some of the events it gets. In this case for example, it might check if ATTACK events are coming in at an unreasonably high frequency.","title":"Events"},{"location":"getting-started/#conclusion","text":"Up to now we had to nastily interrupt the backend process and the client thread by hand in order to end a session. Of course we can also properly terminate everything, for example with >>> client.disconnect(shutdown_server=True) in the client terminal session. Only the first player to connect will have the permission to shutdown the server like this. The backend can also shut itself down with backend.shutdown() . To conclude the conclusion: We have set up a small PyGaSe backend that simulates a moving enemy and handles attack events. Right now, the enemy would never die and its hp would just go into the negative numbers after you hit zero. So good next steps might be to implement a way for this game to end by defeating the drunken master or maybe have the enemy defend itself. Also, a graphical UI wouldn't hurt (I recommend the awesome Arcade library for this). To see how this might be done with PyGaSe you can look through the API reference here or you can take a peek into this little example game of tag , which uses PyGaSe and pygame . For the sake of completeness: # backend.py import math from pygase import GameState, Backend ### SETUP ### # Let there be an imaginary enemy at position 0 with 100 health points. initial_game_state = GameState(position=0, hp=100) # Define what happens in an iteration of the game loop. def time_step(game_state, dt): # Make the imaginary enemy move in sinuous lines like a drunkard. new_position = game_state.position += math.sin(dt) return {\"position\": new_position} # Create the backend. backend = Backend(initial_game_state, time_step) ### EVENT HANDLERS ### def on_attack(attack_position, client_address, game_state, **kwargs): # Check if the attack landed near enough to hit. if abs(attack_position - game_state.position) < 0.1: backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Hit!\", target_client=client_address) # Subtract the attacks damage from the enemies health. return {\"hp\": game_state.hp - 10} backend.server.dispatch_event(\"ATTACK_FEEDBACK\", \"Missed.\", target_client=client_address) return {} backend.game_state_machine.register_event_handler(\"ATTACK\", on_attack) ### MAIN PROCESS ### if __name__ == \"__main__\": backend.run('localhost', 8080)","title":"Conclusion"},{"location":"api/backend/","text":"pygase.backend Serve PyGaSe clients. Provides the Server class and all PyGaSe components that deal with progression and syncing of game states. Contents GameStateStore : main API class for game state repositories Server : main API class for PyGaSe servers GameStateMachine : main API class for game logic components Backend : main API class for a fully integrated PyGaSe backend GameStateStore GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None) Provide access to a game state and manage state updates. Arguments inital_game_state (GameState) : state of the game before the simulation begins Raises TypeError : if 'initial_game_state' is not an instance of GameState get_update_cache GameStateStore.get_update_cache(self) -> list Return the latest state updates. get_game_state GameStateStore.get_game_state(self) -> pygase.gamestate.GameState Return the current game state. push_update GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -> None Push a new state update to the update cache. This method will usually be called by whatever is progressing the game state, usually a GameStateMachine . Server Server(self, game_state_store:pygase.backend.GameStateStore) Listen to clients and orchestrate the flow of events and state updates. The Server instance does not contain game logic or state, it is only responsible for connections to clients. The state is provided by a GameStateStore and game logic by a GameStateMachine . Arguments game_state_store (GameStateStore) : part of the backend that provides an interface to the pygase.GameState Attributes connections (list) : contains each clients address as a key leading to the corresponding pygase.connection.ServerConnection instance host_client (tuple) : address of the host client (who has permission to shutdown the server), if there is any game_state_store (GameStateStore) : game state repository Members hostname (str) : read-only access to the servers hostname port (int) : read-only access to the servers port number hostname Get the hostname or IP address on which the server listens. Returns None when the server is not running. port Get the port number on which the server listens. Returns None when the server is not running. run Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -> None Start the server under a specified address. This is a blocking function but can also be spawned as a coroutine or in a thread via Server.run_in_thread() . Arguments port (int) : port number the server will be bound to, default will be an available port chosen by the computers network controller hostname (str) : hostname or IP address the server will be bound to. Defaults to 'localhost' . event_wire (GameStateMachine) : object to which events are to be repeated (has to implement a _push_event(event) method and is typically a GameStateMachine ) run_in_thread Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -> threading.Thread Start the server in a seperate thread. See Server.run() . Returns threading.Thread : the thread the server loop runs in shutdown Server.shutdown(self) -> None Shut down the server. The server can be restarted via Server.run() in which case it will remember previous connections. This method can also be spawned as a coroutine. dispatch_event Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -> None Send an event to one or all clients. Arguments event_type (str) : identifies the event and links it to a handler target_client (tuple, str) : either 'all' for an event broadcast, or a clients address as a tuple retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be executed after the event was received and be passed a reference to the corresponding pygase.connection.ServerConnection instance Additional positional and keyword arguments will be sent as event data and passed to the clients handler function. register_event_handler Server.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for received events of the given type GameStateMachine GameStateMachine(self, game_state_store:pygase.backend.GameStateStore) Run a simulation that propagates the game state. A GameStateMachine progresses a game state through time, applying all game simulation logic. This class is meant either as a base class from which you inherit and implement the GameStateMachine.time_step() method, or you assign an implementation after instantiation. Arguments game_state_store (GameStateStore) : part of the PyGaSe backend that provides the state Attributes game_time (float) : duration the game has been running in seconds register_event_handler GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. For event handlers to have any effect, the events have to be wired from a Server to the GameStateMachine via the event_wire argument of the Server.run() method. Arguments event_type (str) : which type of event to link the handler function to handler_func (callable, coroutine) : function or coroutine to be invoked for events of the given type In addition to the event data, a GameStateMachine #s handler function gets passed - the following keyword arguments : - - game_state : game state at the time of the event - - dt : time since the last time step - - client_address : client which sent the event that is being handled It is expected to return an update dict like the time_step method. run_game_loop GameStateMachine.run_game_loop(self, interval:float=0.02) -> None Simulate the game world. This function blocks as it continously progresses the game state through time but it can also be spawned as a coroutine or in a thread via Server.run_game_loop_in_thread() . As long as the simulation is running, the game_state.status will be GameStatus.get('Active') . Arguments interval (float) : (minimum) duration in seconds between consecutive time steps run_game_loop_in_thread GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -> threading.Thread Simulate the game in a seperate thread. See GameStateMachine.run_game_loop() . Returns threading.Thread : the thread the game loop runs in stop GameStateMachine.stop(self, timeout:float=1.0) -> bool Pause the game simulation. This sets self.status to Gamestatus.get('Paused') . This method can also be spawned as a coroutine. A subsequent call of GameStateMachine.run_game_loop() will resume the simulation at the point where it was stopped. Arguments timeout (float) : time in seconds to wait for the simulation to stop Returns bool : wether or not the simulation was successfully stopped time_step GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -> dict Calculate a game state update. This method should be implemented to return a dict with all the updated state attributes. Arguments game_state (GameState) : the state of the game prior to the time step dt (float) : time in seconds since the last time step, use it to simulate at a consistent speed Returns dict : updated game state attributes Backend Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None) Easily create a fully integrated PyGaSe backend. Arguments initial_game_state (GameState) : state of the game before the simulation begins time_step_function (callable) : function that takes a game state and a time difference and returns a dict of updated game state attributes (see GameStateMachine.time_step() ) event_handlers (dict) : a dict with event types as keys and event handler functions as values Attributes game_state_store (GameStateStore) : the backends game state repository game_state_machine (GameStateMachine) : logic component that runs the game loop server (Server) : handles connections to PyGaSe clients Example # Run a game loop that continuously increments `foo` with velocity `bar`. Backend( initial_gamestate=GameState(foo=0.0, bar=0.5), time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt}, # Handle client events to reset `foo` and set a new `bar` value. event_handlers={ \"RESET_FOO\": lambda game_state, dt: {foo: 0.0}, \"SET_BAR\": lambda new_bar, game_state, dt: {bar: new_bar} } ).run(hostname=\"localhost\", port=8080) run Backend.run(self, hostname:str, port:int) Run state machine and server and bind the server to a given address. Arguments hostname (str) : hostname or IPv4 address the server will be bound to port (int) : port number the server will be bound to shutdown Backend.shutdown(self) Shut down server and stop game loop.","title":"pygase.backend"},{"location":"api/backend/#pygasebackend","text":"Serve PyGaSe clients. Provides the Server class and all PyGaSe components that deal with progression and syncing of game states. Contents GameStateStore : main API class for game state repositories Server : main API class for PyGaSe servers GameStateMachine : main API class for game logic components Backend : main API class for a fully integrated PyGaSe backend","title":"pygase.backend"},{"location":"api/backend/#gamestatestore","text":"GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None) Provide access to a game state and manage state updates. Arguments inital_game_state (GameState) : state of the game before the simulation begins Raises TypeError : if 'initial_game_state' is not an instance of GameState","title":"GameStateStore"},{"location":"api/backend/#get_update_cache","text":"GameStateStore.get_update_cache(self) -> list Return the latest state updates.","title":"get_update_cache"},{"location":"api/backend/#get_game_state","text":"GameStateStore.get_game_state(self) -> pygase.gamestate.GameState Return the current game state.","title":"get_game_state"},{"location":"api/backend/#push_update","text":"GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -> None Push a new state update to the update cache. This method will usually be called by whatever is progressing the game state, usually a GameStateMachine .","title":"push_update"},{"location":"api/backend/#server","text":"Server(self, game_state_store:pygase.backend.GameStateStore) Listen to clients and orchestrate the flow of events and state updates. The Server instance does not contain game logic or state, it is only responsible for connections to clients. The state is provided by a GameStateStore and game logic by a GameStateMachine . Arguments game_state_store (GameStateStore) : part of the backend that provides an interface to the pygase.GameState Attributes connections (list) : contains each clients address as a key leading to the corresponding pygase.connection.ServerConnection instance host_client (tuple) : address of the host client (who has permission to shutdown the server), if there is any game_state_store (GameStateStore) : game state repository Members hostname (str) : read-only access to the servers hostname port (int) : read-only access to the servers port number","title":"Server"},{"location":"api/backend/#hostname","text":"Get the hostname or IP address on which the server listens. Returns None when the server is not running.","title":"hostname"},{"location":"api/backend/#port","text":"Get the port number on which the server listens. Returns None when the server is not running.","title":"port"},{"location":"api/backend/#run","text":"Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -> None Start the server under a specified address. This is a blocking function but can also be spawned as a coroutine or in a thread via Server.run_in_thread() . Arguments port (int) : port number the server will be bound to, default will be an available port chosen by the computers network controller hostname (str) : hostname or IP address the server will be bound to. Defaults to 'localhost' . event_wire (GameStateMachine) : object to which events are to be repeated (has to implement a _push_event(event) method and is typically a GameStateMachine )","title":"run"},{"location":"api/backend/#run_in_thread","text":"Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -> threading.Thread Start the server in a seperate thread. See Server.run() . Returns threading.Thread : the thread the server loop runs in","title":"run_in_thread"},{"location":"api/backend/#shutdown","text":"Server.shutdown(self) -> None Shut down the server. The server can be restarted via Server.run() in which case it will remember previous connections. This method can also be spawned as a coroutine.","title":"shutdown"},{"location":"api/backend/#dispatch_event","text":"Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -> None Send an event to one or all clients. Arguments event_type (str) : identifies the event and links it to a handler target_client (tuple, str) : either 'all' for an event broadcast, or a clients address as a tuple retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be executed after the event was received and be passed a reference to the corresponding pygase.connection.ServerConnection instance Additional positional and keyword arguments will be sent as event data and passed to the clients handler function.","title":"dispatch_event"},{"location":"api/backend/#register_event_handler","text":"Server.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for received events of the given type","title":"register_event_handler"},{"location":"api/backend/#gamestatemachine","text":"GameStateMachine(self, game_state_store:pygase.backend.GameStateStore) Run a simulation that propagates the game state. A GameStateMachine progresses a game state through time, applying all game simulation logic. This class is meant either as a base class from which you inherit and implement the GameStateMachine.time_step() method, or you assign an implementation after instantiation. Arguments game_state_store (GameStateStore) : part of the PyGaSe backend that provides the state Attributes game_time (float) : duration the game has been running in seconds","title":"GameStateMachine"},{"location":"api/backend/#register_event_handler_1","text":"GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. For event handlers to have any effect, the events have to be wired from a Server to the GameStateMachine via the event_wire argument of the Server.run() method. Arguments event_type (str) : which type of event to link the handler function to handler_func (callable, coroutine) : function or coroutine to be invoked for events of the given type In addition to the event data, a GameStateMachine #s handler function gets passed - the following keyword arguments : - - game_state : game state at the time of the event - - dt : time since the last time step - - client_address : client which sent the event that is being handled It is expected to return an update dict like the time_step method.","title":"register_event_handler"},{"location":"api/backend/#run_game_loop","text":"GameStateMachine.run_game_loop(self, interval:float=0.02) -> None Simulate the game world. This function blocks as it continously progresses the game state through time but it can also be spawned as a coroutine or in a thread via Server.run_game_loop_in_thread() . As long as the simulation is running, the game_state.status will be GameStatus.get('Active') . Arguments interval (float) : (minimum) duration in seconds between consecutive time steps","title":"run_game_loop"},{"location":"api/backend/#run_game_loop_in_thread","text":"GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -> threading.Thread Simulate the game in a seperate thread. See GameStateMachine.run_game_loop() . Returns threading.Thread : the thread the game loop runs in","title":"run_game_loop_in_thread"},{"location":"api/backend/#stop","text":"GameStateMachine.stop(self, timeout:float=1.0) -> bool Pause the game simulation. This sets self.status to Gamestatus.get('Paused') . This method can also be spawned as a coroutine. A subsequent call of GameStateMachine.run_game_loop() will resume the simulation at the point where it was stopped. Arguments timeout (float) : time in seconds to wait for the simulation to stop Returns bool : wether or not the simulation was successfully stopped","title":"stop"},{"location":"api/backend/#time_step","text":"GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -> dict Calculate a game state update. This method should be implemented to return a dict with all the updated state attributes. Arguments game_state (GameState) : the state of the game prior to the time step dt (float) : time in seconds since the last time step, use it to simulate at a consistent speed Returns dict : updated game state attributes","title":"time_step"},{"location":"api/backend/#backend","text":"Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None) Easily create a fully integrated PyGaSe backend. Arguments initial_game_state (GameState) : state of the game before the simulation begins time_step_function (callable) : function that takes a game state and a time difference and returns a dict of updated game state attributes (see GameStateMachine.time_step() ) event_handlers (dict) : a dict with event types as keys and event handler functions as values Attributes game_state_store (GameStateStore) : the backends game state repository game_state_machine (GameStateMachine) : logic component that runs the game loop server (Server) : handles connections to PyGaSe clients Example # Run a game loop that continuously increments `foo` with velocity `bar`. Backend( initial_gamestate=GameState(foo=0.0, bar=0.5), time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt}, # Handle client events to reset `foo` and set a new `bar` value. event_handlers={ \"RESET_FOO\": lambda game_state, dt: {foo: 0.0}, \"SET_BAR\": lambda new_bar, game_state, dt: {bar: new_bar} } ).run(hostname=\"localhost\", port=8080)","title":"Backend"},{"location":"api/backend/#run_1","text":"Backend.run(self, hostname:str, port:int) Run state machine and server and bind the server to a given address. Arguments hostname (str) : hostname or IPv4 address the server will be bound to port (int) : port number the server will be bound to","title":"run"},{"location":"api/backend/#shutdown_1","text":"Backend.shutdown(self) Shut down server and stop game loop.","title":"shutdown"},{"location":"api/client/","text":"pygase.client Connect to PyGaSe servers. Contents Client : main API class for PyGaSe clients Client Client(self) Exchange events with a PyGaSe server and access a synchronized game state. Attributes connection (pygase.connection.ClientConnection) : object that contains all networking information Example from time import sleep # Connect a client to the server from the Backend code example client = Client() client.connect_in_thread(hostname=\"localhost\", port=8080) # Increase `bar` five times, then reset `foo` for i in range(5): client.dispatch_event(\"SET_BAR\", new_bar=i) sleep(1) client.dispatch_event(\"RESET_FOO\") connect Client.connect(self, port:int, hostname:str='localhost') -> None Open a connection to a PyGaSe server. This is a blocking function but can also be spawned as a coroutine or in a thread via Client.connect_in_thread() . Arguments port (int) : port number of the server to which to connect hostname (str) : hostname or IPv4 address of the server to which to connect connect_in_thread Client.connect_in_thread(self, port:int, hostname:str='localhost') -> threading.Thread Open a connection in a seperate thread. See Client.connect() . Returns threading.Thread : the thread the client loop runs in disconnect Client.disconnect(self, shutdown_server:bool=False) -> None Close the client connection. This method can also be spawned as a coroutine. shutdown_server (bool): wether or not the server should be shut down (only has an effect if the client has host permissions) access_game_state Client.access_game_state(self) Return a context manager to access the shared game state. Can be used in a with block to lock the synchronized game_state while working with it. Example with client.access_game_state() as game_state: do_stuff(game_state) wait_until Client.wait_until(self, game_state_condition, timeout:float=1.0) -> None Block until a condition on the game state is satisfied. Arguments game_state_condition (callable) : function that takes a pygase.GameState instance and returns a bool timeout (float) : time in seconds after which to raise a TimeoutError Raises TimeoutError : if the condition is not met after timeout seconds try_to Client.try_to(self, function, timeout:float=1.0) Execute a function using game state attributes that might not yet exist. This method repeatedly tries to execute function(game_state) , ignoring KeyError exceptions, until it either worksor times out. Arguments function (callable) : function that takes a pygase.GameState instance and returns anything timeout (float) : time in seconds after which to raise a TimeoutError Returns any : whatever function(game_state) returns Raises TimeoutError : if the function doesn't run through after timeout seconds dispatch_event Client.dispatch_event(self, event_type:str, *args, retries:int=0, ack_callback=None, **kwargs) -> None Send an event to the server. Arguments event_type (str) : event type identifier that links to a handler retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be invoked after the event was received Additional positional and keyword arguments will be sent as event data and passed to the handler function. ack_callback should not perform any long-running blocking operations (say a while True loop), as that will block the connections asynchronous event loop. Use a coroutine instead, with appropriately placed await s. register_event_handler Client.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for events of the given type","title":"pygase.client"},{"location":"api/client/#pygaseclient","text":"Connect to PyGaSe servers. Contents Client : main API class for PyGaSe clients","title":"pygase.client"},{"location":"api/client/#client","text":"Client(self) Exchange events with a PyGaSe server and access a synchronized game state. Attributes connection (pygase.connection.ClientConnection) : object that contains all networking information Example from time import sleep # Connect a client to the server from the Backend code example client = Client() client.connect_in_thread(hostname=\"localhost\", port=8080) # Increase `bar` five times, then reset `foo` for i in range(5): client.dispatch_event(\"SET_BAR\", new_bar=i) sleep(1) client.dispatch_event(\"RESET_FOO\")","title":"Client"},{"location":"api/client/#connect","text":"Client.connect(self, port:int, hostname:str='localhost') -> None Open a connection to a PyGaSe server. This is a blocking function but can also be spawned as a coroutine or in a thread via Client.connect_in_thread() . Arguments port (int) : port number of the server to which to connect hostname (str) : hostname or IPv4 address of the server to which to connect","title":"connect"},{"location":"api/client/#connect_in_thread","text":"Client.connect_in_thread(self, port:int, hostname:str='localhost') -> threading.Thread Open a connection in a seperate thread. See Client.connect() . Returns threading.Thread : the thread the client loop runs in","title":"connect_in_thread"},{"location":"api/client/#disconnect","text":"Client.disconnect(self, shutdown_server:bool=False) -> None Close the client connection. This method can also be spawned as a coroutine. shutdown_server (bool): wether or not the server should be shut down (only has an effect if the client has host permissions)","title":"disconnect"},{"location":"api/client/#access_game_state","text":"Client.access_game_state(self) Return a context manager to access the shared game state. Can be used in a with block to lock the synchronized game_state while working with it. Example with client.access_game_state() as game_state: do_stuff(game_state)","title":"access_game_state"},{"location":"api/client/#wait_until","text":"Client.wait_until(self, game_state_condition, timeout:float=1.0) -> None Block until a condition on the game state is satisfied. Arguments game_state_condition (callable) : function that takes a pygase.GameState instance and returns a bool timeout (float) : time in seconds after which to raise a TimeoutError Raises TimeoutError : if the condition is not met after timeout seconds","title":"wait_until"},{"location":"api/client/#try_to","text":"Client.try_to(self, function, timeout:float=1.0) Execute a function using game state attributes that might not yet exist. This method repeatedly tries to execute function(game_state) , ignoring KeyError exceptions, until it either worksor times out. Arguments function (callable) : function that takes a pygase.GameState instance and returns anything timeout (float) : time in seconds after which to raise a TimeoutError Returns any : whatever function(game_state) returns Raises TimeoutError : if the function doesn't run through after timeout seconds","title":"try_to"},{"location":"api/client/#dispatch_event","text":"Client.dispatch_event(self, event_type:str, *args, retries:int=0, ack_callback=None, **kwargs) -> None Send an event to the server. Arguments event_type (str) : event type identifier that links to a handler retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be invoked after the event was received Additional positional and keyword arguments will be sent as event data and passed to the handler function. ack_callback should not perform any long-running blocking operations (say a while True loop), as that will block the connections asynchronous event loop. Use a coroutine instead, with appropriately placed await s.","title":"dispatch_event"},{"location":"api/client/#register_event_handler","text":"Client.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for events of the given type","title":"register_event_handler"},{"location":"api/connection/","text":"pygase.connection Provide low-level networking logic. This module is not supposed to be required by users of this library. Contents PROTOCOL_ID : 4 byte identifier for the PyGaSe package protocol ProtocolIDMismatchError : exception for receiving non-PyGaSe packages DuplicateSequenceError : exception for duplicate packages Header : class for PyGaSe package headers Package : class for PyGaSe UDP packages ClientPackage : subclass of Package for packages sent by clients ServerPackage : subclass of Package for packages sent by servers ConnectionStatus : enum for the status of a client-server connection Connection : class for the core network logic of client-server connections ClientConnection : subclass of Connection for the client side ServerConnection : subclass of Connectoin for the server side ProtocolIDMismatchError ProtocolIDMismatchError(self, /, *args, **kwargs) Bytestring could not be identified as a valid PyGaSe package. DuplicateSequenceError DuplicateSequenceError(self, /, *args, **kwargs) Received a package with a sequence number that was already received before. Header Header(self, sequence:int, ack:int, ack_bitfield:str) Create a PyGaSe package header. Arguments sequence (int) : package sequence number ack (int) : sequence number of the last received package ack_bitfield (str) : A 32 character string representing the 32 sequence numbers prior to the last one received, with the first character corresponding the packge directly preceding it and so forth. '1' means that package has been received, '0' means it hasn't. Attributes sequence (int) : see corresponding constructor argument ack (int) : see corresponding constructor argument ack_bitfield (str) : see corresponding constructor argument Sequence numbers : A sequence of 0 means no packages have been sent or received. After 65535 sequence numbers wrap around to 1, so they can be stored in 2 bytes. to_bytearray Header.to_bytearray(self) -> bytearray Return 12 bytes representing the header. destructure Header.destructure(self) -> tuple Return the tuple (sequence, ack, ack_bitfield) . deconstruct_datagram Header.deconstruct_datagram(datagram:bytes) -> tuple Return a tuple containing the header and the rest of the datagram. Arguments datagram (bytes) : serialized PyGaSe package to deconstruct Returns tuple : (header, payload) with payload being a bytestring of the rest of the datagram Package Package(self, header:pygase.connection.Header, events:list=None) Create a UDP package implementing the PyGaSe protocol. Arguments header (Header) : package header Arguments events (pygase.event.Event) : list events to attach to this package Attributes header (Header) : Members events (pygase.event.Event) : see corresponding constructor argument PyGaSe servers and clients use the subclasses ServerPackage and ClientPackage respectively. The Package class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state. events Get a list of the events in the package. add_event Package.add_event(self, event:pygase.event.Event) -> None Add a PyGaSe event to the package. Arguments event (pygase.event.Event) : the event to be attached to this package Raises OverflowError : if the package has previously been converted to a datagram and and its size with the added event would exceed Package._max_size (2048 bytex) get_bytesize Package.get_bytesize(self) -> int Return the size in bytes the package has as a datagram. to_datagram Package.to_datagram(self) -> bytes Return package compactly serialized to bytes . Raises OverflowError : if the resulting datagram would exceed Package._max_size from_datagram Package.from_datagram(datagram:bytes) -> 'Package' Deserialize datagram to Package . Arguments datagram (bytes) : bytestring to deserialize, typically received via network Returns Package : the deserialized package Raises ProtocolIDMismatchError : if the first four bytes don't match the PyGaSe protocol ID ClientPackage ClientPackage(self, header:pygase.connection.Header, time_order:int, events:list=None) Subclass of Package for packages sent by PyGaSe clients. Arguments time_order (int) : the clients last known time order of the game state Attributes time_order (int) : see corresponding constructor argument to_datagram ClientPackage.to_datagram(self) -> bytes Override Package.to_datagram to include time_order . from_datagram ClientPackage.from_datagram(datagram:bytes) -> 'ClientPackage' Override Package.from_datagram to include time_order . ServerPackage ServerPackage(self, header:pygase.connection.Header, game_state_update:pygase.gamestate.GameStateUpdate, events:list=None) Subclass of Package for packages sent by PyGaSe servers. Arguments game_state_update (pygase.gamestate.GameStateUpdate) : the servers most recent minimal update for the client to_datagram ServerPackage.to_datagram(self) -> bytes Override Package.to_datagram to include game_state_update . from_datagram ServerPackage.from_datagram(datagram:bytes) -> 'ServerPackage' Override Package.from_datagram to include game_state_update . ConnectionStatus ConnectionStatus(self, /, *args, **kwargs) Enum for the state of a connection. 'Disconnected' 'Connecting' 'Connected' Connection Connection(self, remote_address:tuple, event_handler, event_wire=None) Exchange packages between PyGaSe clients and servers. PyGaSe connections exchange events with their other side which are handled using custom handler functions. They also keep each other informed about which packages have been sent and received and automatically avoid network congestion. Arguments remote_address (tuple) : ('hostname', port) for the connection partner's address event_handler (pygase.event.UniversalEventHandler) : object that has a callable handle attribute that takes a pygase.event.Event as argument event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method) Attributes remote_address (tuple) : see corresponding constructor argument event_handler (pygase.event.UniversalEventHandler) : see corresponding constructor argument event_wire (pygase.GameStateMachine) : see corresponding constructor argument local_sequence (pygase.utils.Sqn) : sequence number of the last sent package remote_sequence (pygase.utils.Sqn) : sequence number of the last received package ack_bitfield (str) : acks for the 32 packages prior to self.remote_sequence latency (float) : the last registered RTT (round trip time) status (ConnectionStatus) : an integer value that informs about the state of the connections quality (str) : either 'good' or 'bad' depending on latency, used internally for congestion avoidance PyGaSe servers and clients use the subclasses ServerConnection and ClientConnection respectively. The Connection class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state. dispatch_event Connection.dispatch_event(self, event:pygase.event.Event, ack_callback=None, timeout_callback=None) Send an event to the connection partner. Arguments event (pygase.event.Event) : the event to dispatch ack_callback (callable, coroutine) : will be executed after the event was received timeout_callback (callable, coroutine) : will be executed if the event was not received Using long-running blocking operations in any of the callback functions can disturb the connection. ClientConnection ClientConnection(self, remote_address:tuple, event_handler) Subclass of Connection to describe the client side of a PyGaSe connection. Client connections hold a copy of the game state which is continously being updated according to state updates received from the server. Attributes game_state_context (pygase.utils.LockedRessource) : provides thread-safe access to a pygase.GameState shutdown ClientConnection.shutdown(self, shutdown_server:bool=False) Shut down the client connection. This method can also be spawned as a coroutine. Arguments shutdown_server (bool) : wether or not the server should be shut down too (only has an effect if the client has host permissions) loop ClientConnection.loop(self) Continously operate the connection. This method will keep sending and receiving packages and handling events until it is cancelled or the connection receives a shutdown command. It can also be spawned as a coroutine. ServerConnection ServerConnection(self, remote_address:tuple, event_handler, game_state_store, last_client_time_order:pygase.utils.Sqn, event_wire=None) Subclass of Connection that describes the server side of a PyGaSe connection. Arguments game_state_store (pygase.GameStateStore) : object that serves as an interface to the game state repository (has to provide the methods get_gamestate , get_update_cache and push_update ) last_client_time_order (pygase.utils.Sqn) : the last time order number known to the client Attributes game_state_store (pygase.GameStateStore) : see corresponding constructor argument last_client_time_order (pygase.utils.Sqn) : see corresponding constructor argument loop ServerConnection.loop(hostname:str, port:int, server, event_wire) -> None Continously orchestrate and operate connections to clients. This coroutine will keep listening for client packages, create new ServerConnection objects when necessary and make sure all packages are handled by and sent via the right connection. It will return as soon as the server receives a shutdown message. Arguments hostname (str) : the hostname or IPv4 address to which to bind the server socket port (int) : the port number to which to bind the server socket server (pygase.Server) : the server for which this loop is run event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method)","title":"pygase.connection"},{"location":"api/connection/#pygaseconnection","text":"Provide low-level networking logic. This module is not supposed to be required by users of this library. Contents PROTOCOL_ID : 4 byte identifier for the PyGaSe package protocol ProtocolIDMismatchError : exception for receiving non-PyGaSe packages DuplicateSequenceError : exception for duplicate packages Header : class for PyGaSe package headers Package : class for PyGaSe UDP packages ClientPackage : subclass of Package for packages sent by clients ServerPackage : subclass of Package for packages sent by servers ConnectionStatus : enum for the status of a client-server connection Connection : class for the core network logic of client-server connections ClientConnection : subclass of Connection for the client side ServerConnection : subclass of Connectoin for the server side","title":"pygase.connection"},{"location":"api/connection/#protocolidmismatcherror","text":"ProtocolIDMismatchError(self, /, *args, **kwargs) Bytestring could not be identified as a valid PyGaSe package.","title":"ProtocolIDMismatchError"},{"location":"api/connection/#duplicatesequenceerror","text":"DuplicateSequenceError(self, /, *args, **kwargs) Received a package with a sequence number that was already received before.","title":"DuplicateSequenceError"},{"location":"api/connection/#header","text":"Header(self, sequence:int, ack:int, ack_bitfield:str) Create a PyGaSe package header. Arguments sequence (int) : package sequence number ack (int) : sequence number of the last received package ack_bitfield (str) : A 32 character string representing the 32 sequence numbers prior to the last one received, with the first character corresponding the packge directly preceding it and so forth. '1' means that package has been received, '0' means it hasn't. Attributes sequence (int) : see corresponding constructor argument ack (int) : see corresponding constructor argument ack_bitfield (str) : see corresponding constructor argument Sequence numbers : A sequence of 0 means no packages have been sent or received. After 65535 sequence numbers wrap around to 1, so they can be stored in 2 bytes.","title":"Header"},{"location":"api/connection/#to_bytearray","text":"Header.to_bytearray(self) -> bytearray Return 12 bytes representing the header.","title":"to_bytearray"},{"location":"api/connection/#destructure","text":"Header.destructure(self) -> tuple Return the tuple (sequence, ack, ack_bitfield) .","title":"destructure"},{"location":"api/connection/#deconstruct_datagram","text":"Header.deconstruct_datagram(datagram:bytes) -> tuple Return a tuple containing the header and the rest of the datagram. Arguments datagram (bytes) : serialized PyGaSe package to deconstruct Returns tuple : (header, payload) with payload being a bytestring of the rest of the datagram","title":"deconstruct_datagram"},{"location":"api/connection/#package","text":"Package(self, header:pygase.connection.Header, events:list=None) Create a UDP package implementing the PyGaSe protocol. Arguments header (Header) : package header Arguments events (pygase.event.Event) : list events to attach to this package Attributes header (Header) : Members events (pygase.event.Event) : see corresponding constructor argument PyGaSe servers and clients use the subclasses ServerPackage and ClientPackage respectively. The Package class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state.","title":"Package"},{"location":"api/connection/#events","text":"Get a list of the events in the package.","title":"events"},{"location":"api/connection/#add_event","text":"Package.add_event(self, event:pygase.event.Event) -> None Add a PyGaSe event to the package. Arguments event (pygase.event.Event) : the event to be attached to this package Raises OverflowError : if the package has previously been converted to a datagram and and its size with the added event would exceed Package._max_size (2048 bytex)","title":"add_event"},{"location":"api/connection/#get_bytesize","text":"Package.get_bytesize(self) -> int Return the size in bytes the package has as a datagram.","title":"get_bytesize"},{"location":"api/connection/#to_datagram","text":"Package.to_datagram(self) -> bytes Return package compactly serialized to bytes . Raises OverflowError : if the resulting datagram would exceed Package._max_size","title":"to_datagram"},{"location":"api/connection/#from_datagram","text":"Package.from_datagram(datagram:bytes) -> 'Package' Deserialize datagram to Package . Arguments datagram (bytes) : bytestring to deserialize, typically received via network Returns Package : the deserialized package Raises ProtocolIDMismatchError : if the first four bytes don't match the PyGaSe protocol ID","title":"from_datagram"},{"location":"api/connection/#clientpackage","text":"ClientPackage(self, header:pygase.connection.Header, time_order:int, events:list=None) Subclass of Package for packages sent by PyGaSe clients. Arguments time_order (int) : the clients last known time order of the game state Attributes time_order (int) : see corresponding constructor argument","title":"ClientPackage"},{"location":"api/connection/#to_datagram_1","text":"ClientPackage.to_datagram(self) -> bytes Override Package.to_datagram to include time_order .","title":"to_datagram"},{"location":"api/connection/#from_datagram_1","text":"ClientPackage.from_datagram(datagram:bytes) -> 'ClientPackage' Override Package.from_datagram to include time_order .","title":"from_datagram"},{"location":"api/connection/#serverpackage","text":"ServerPackage(self, header:pygase.connection.Header, game_state_update:pygase.gamestate.GameStateUpdate, events:list=None) Subclass of Package for packages sent by PyGaSe servers. Arguments game_state_update (pygase.gamestate.GameStateUpdate) : the servers most recent minimal update for the client","title":"ServerPackage"},{"location":"api/connection/#to_datagram_2","text":"ServerPackage.to_datagram(self) -> bytes Override Package.to_datagram to include game_state_update .","title":"to_datagram"},{"location":"api/connection/#from_datagram_2","text":"ServerPackage.from_datagram(datagram:bytes) -> 'ServerPackage' Override Package.from_datagram to include game_state_update .","title":"from_datagram"},{"location":"api/connection/#connectionstatus","text":"ConnectionStatus(self, /, *args, **kwargs) Enum for the state of a connection. 'Disconnected' 'Connecting' 'Connected'","title":"ConnectionStatus"},{"location":"api/connection/#connection","text":"Connection(self, remote_address:tuple, event_handler, event_wire=None) Exchange packages between PyGaSe clients and servers. PyGaSe connections exchange events with their other side which are handled using custom handler functions. They also keep each other informed about which packages have been sent and received and automatically avoid network congestion. Arguments remote_address (tuple) : ('hostname', port) for the connection partner's address event_handler (pygase.event.UniversalEventHandler) : object that has a callable handle attribute that takes a pygase.event.Event as argument event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method) Attributes remote_address (tuple) : see corresponding constructor argument event_handler (pygase.event.UniversalEventHandler) : see corresponding constructor argument event_wire (pygase.GameStateMachine) : see corresponding constructor argument local_sequence (pygase.utils.Sqn) : sequence number of the last sent package remote_sequence (pygase.utils.Sqn) : sequence number of the last received package ack_bitfield (str) : acks for the 32 packages prior to self.remote_sequence latency (float) : the last registered RTT (round trip time) status (ConnectionStatus) : an integer value that informs about the state of the connections quality (str) : either 'good' or 'bad' depending on latency, used internally for congestion avoidance PyGaSe servers and clients use the subclasses ServerConnection and ClientConnection respectively. The Connection class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state.","title":"Connection"},{"location":"api/connection/#dispatch_event","text":"Connection.dispatch_event(self, event:pygase.event.Event, ack_callback=None, timeout_callback=None) Send an event to the connection partner. Arguments event (pygase.event.Event) : the event to dispatch ack_callback (callable, coroutine) : will be executed after the event was received timeout_callback (callable, coroutine) : will be executed if the event was not received Using long-running blocking operations in any of the callback functions can disturb the connection.","title":"dispatch_event"},{"location":"api/connection/#clientconnection","text":"ClientConnection(self, remote_address:tuple, event_handler) Subclass of Connection to describe the client side of a PyGaSe connection. Client connections hold a copy of the game state which is continously being updated according to state updates received from the server. Attributes game_state_context (pygase.utils.LockedRessource) : provides thread-safe access to a pygase.GameState","title":"ClientConnection"},{"location":"api/connection/#shutdown","text":"ClientConnection.shutdown(self, shutdown_server:bool=False) Shut down the client connection. This method can also be spawned as a coroutine. Arguments shutdown_server (bool) : wether or not the server should be shut down too (only has an effect if the client has host permissions)","title":"shutdown"},{"location":"api/connection/#loop","text":"ClientConnection.loop(self) Continously operate the connection. This method will keep sending and receiving packages and handling events until it is cancelled or the connection receives a shutdown command. It can also be spawned as a coroutine.","title":"loop"},{"location":"api/connection/#serverconnection","text":"ServerConnection(self, remote_address:tuple, event_handler, game_state_store, last_client_time_order:pygase.utils.Sqn, event_wire=None) Subclass of Connection that describes the server side of a PyGaSe connection. Arguments game_state_store (pygase.GameStateStore) : object that serves as an interface to the game state repository (has to provide the methods get_gamestate , get_update_cache and push_update ) last_client_time_order (pygase.utils.Sqn) : the last time order number known to the client Attributes game_state_store (pygase.GameStateStore) : see corresponding constructor argument last_client_time_order (pygase.utils.Sqn) : see corresponding constructor argument","title":"ServerConnection"},{"location":"api/connection/#loop_1","text":"ServerConnection.loop(hostname:str, port:int, server, event_wire) -> None Continously orchestrate and operate connections to clients. This coroutine will keep listening for client packages, create new ServerConnection objects when necessary and make sure all packages are handled by and sent via the right connection. It will return as soon as the server receives a shutdown message. Arguments hostname (str) : the hostname or IPv4 address to which to bind the server socket port (int) : the port number to which to bind the server socket server (pygase.Server) : the server for which this loop is run event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method)","title":"loop"},{"location":"api/event/","text":"pygase.event Handle events in PyGaSe clients, servers and state machines. Contains the basic components of the PyGaSe event framework. Contents Event : class for serializable event objects with event type and data UniversalEventHandler : class for components that can handle various event types Event Event(self, event_type:str, *args, **kwargs) Send PyGaSe events and attached data via UDP packages. Arguments event_type (str) : string that identifies the event and links it to a handler Arguments Additional positional arguments represent event data and will be passed to the handler function on the other side of the connection. keyword arguments to be passed to the handler function on the other side of the connection Attributes type (str) : handler_args (list) : handler_kwargs (dict) : UniversalEventHandler UniversalEventHandler(self) Handle PyGaSe events with callback functions. register_event_handler UniversalEventHandler.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : string that identifies the events to be handled by this function event_handler_function (callable, coroutine) : callback function or coroutine that will be invoked with the handler args and kwargs with which the incoming event has been dispatched Raises TypeError : if event_handler_function is not callable handle UniversalEventHandler.handle(self, event:pygase.event.Event, **kwargs) Asynchronously invoke the appropriate handler function. This method is a coroutine and must be await ed. Arguments event (Event) : the event to be handled keyword arguments to be passed to the handler function (in addition to those already attached to the event) has_event_type UniversalEventHandler.has_event_type(self, event_type:str) -> bool Check if a handler was registered for event_type .","title":"pygase.event"},{"location":"api/event/#pygaseevent","text":"Handle events in PyGaSe clients, servers and state machines. Contains the basic components of the PyGaSe event framework.","title":"pygase.event"},{"location":"api/event/#contents","text":"Event : class for serializable event objects with event type and data UniversalEventHandler : class for components that can handle various event types","title":"Contents"},{"location":"api/event/#event","text":"Event(self, event_type:str, *args, **kwargs) Send PyGaSe events and attached data via UDP packages. Arguments event_type (str) : string that identifies the event and links it to a handler Arguments Additional positional arguments represent event data and will be passed to the handler function on the other side of the connection. keyword arguments to be passed to the handler function on the other side of the connection Attributes type (str) : handler_args (list) : handler_kwargs (dict) :","title":"Event"},{"location":"api/event/#universaleventhandler","text":"UniversalEventHandler(self) Handle PyGaSe events with callback functions.","title":"UniversalEventHandler"},{"location":"api/event/#register_event_handler","text":"UniversalEventHandler.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : string that identifies the events to be handled by this function event_handler_function (callable, coroutine) : callback function or coroutine that will be invoked with the handler args and kwargs with which the incoming event has been dispatched Raises TypeError : if event_handler_function is not callable","title":"register_event_handler"},{"location":"api/event/#handle","text":"UniversalEventHandler.handle(self, event:pygase.event.Event, **kwargs) Asynchronously invoke the appropriate handler function. This method is a coroutine and must be await ed. Arguments event (Event) : the event to be handled keyword arguments to be passed to the handler function (in addition to those already attached to the event)","title":"handle"},{"location":"api/event/#has_event_type","text":"UniversalEventHandler.has_event_type(self, event_type:str) -> bool Check if a handler was registered for event_type .","title":"has_event_type"},{"location":"api/gamestate/","text":"pygase.gamestate Customize a game state model and apply state updates. Contents TO_DELETE : 4 byte update marker for game state attributes that are to be deleted GameStatus : enum for the status of the game simulation GameState : class for serializable custom state data objects GameStateUpdate : class for serializable objects that express changes to a GameState object GameStatus GameStatus(self, /, *args, **kwargs) Enum for the game simulation status. 'Paused' 'Active' GameState GameState(self, time_order:int=0, game_status:int=0, **kwargs) Customize a serializable game state model. Contains game state information that will be synchronized between the server and the clients. Via pygase.utils.Sendable its instances will be serialized using the msgpack protocol and must only contain attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. Arguments time_order () : current time order number of the game state, higher means more recent game_status () : GameStatus enum value that describes whether or not the game loop is running Provide custom game state attributes via keyword arguments or assign them later. Attributes game_status () time_order () GameState instances mainly consist of custom attributes that make up the game state. is_paused GameState.is_paused(self) -> bool Return True if game is paused. GameStateUpdate GameStateUpdate(self, time_order:int, **kwargs) Update a GameState object. Contains a set of changes to carry out on a GameState . The server keeps a time_order counter and labels all updates in ascending order. Attributes of a GameStateUpdate object represent new values of GameState attributes. To remove game state attributes just assign TO_DELETE to it in the update. Use the + operator to add updates to one another and combine them or to add them to a game state in order to update it. Arguments time_order () : the time order up to which the update reaches game state attributes to be updated Attributes time_order () GameStateUpdate instances mainly consist of custom game state attributes to update. from_bytes GameStateUpdate.from_bytes(bytepack:bytes) -> 'GameStateUpdate' Extend Sendable.from_bytes to make sure time_order is of type Sqn .","title":"pygase.gamestate"},{"location":"api/gamestate/#pygasegamestate","text":"Customize a game state model and apply state updates.","title":"pygase.gamestate"},{"location":"api/gamestate/#contents","text":"TO_DELETE : 4 byte update marker for game state attributes that are to be deleted GameStatus : enum for the status of the game simulation GameState : class for serializable custom state data objects GameStateUpdate : class for serializable objects that express changes to a GameState object","title":"Contents"},{"location":"api/gamestate/#gamestatus","text":"GameStatus(self, /, *args, **kwargs) Enum for the game simulation status. 'Paused' 'Active'","title":"GameStatus"},{"location":"api/gamestate/#gamestate","text":"GameState(self, time_order:int=0, game_status:int=0, **kwargs) Customize a serializable game state model. Contains game state information that will be synchronized between the server and the clients. Via pygase.utils.Sendable its instances will be serialized using the msgpack protocol and must only contain attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. Arguments time_order () : current time order number of the game state, higher means more recent game_status () : GameStatus enum value that describes whether or not the game loop is running Provide custom game state attributes via keyword arguments or assign them later. Attributes game_status () time_order () GameState instances mainly consist of custom attributes that make up the game state.","title":"GameState"},{"location":"api/gamestate/#is_paused","text":"GameState.is_paused(self) -> bool Return True if game is paused.","title":"is_paused"},{"location":"api/gamestate/#gamestateupdate","text":"GameStateUpdate(self, time_order:int, **kwargs) Update a GameState object. Contains a set of changes to carry out on a GameState . The server keeps a time_order counter and labels all updates in ascending order. Attributes of a GameStateUpdate object represent new values of GameState attributes. To remove game state attributes just assign TO_DELETE to it in the update. Use the + operator to add updates to one another and combine them or to add them to a game state in order to update it. Arguments time_order () : the time order up to which the update reaches game state attributes to be updated Attributes time_order () GameStateUpdate instances mainly consist of custom game state attributes to update.","title":"GameStateUpdate"},{"location":"api/gamestate/#from_bytes","text":"GameStateUpdate.from_bytes(bytepack:bytes) -> 'GameStateUpdate' Extend Sendable.from_bytes to make sure time_order is of type Sqn .","title":"from_bytes"},{"location":"api/low-level/","text":"pygase.client Connect to PyGaSe servers. Contents Client : main API class for PyGaSe clients Client Client(self) Exchange events with a PyGaSe server and access a synchronized game state. Attributes connection (pygase.connection.ClientConnection) : object that contains all networking information Example from time import sleep # Connect a client to the server from the Backend code example client = Client() client.connect_in_thread(hostname=\"localhost\", port=8080) # Increase `bar` five times, then reset `foo` for i in range(5): client.dispatch_event(\"SET_BAR\", new_bar=i) sleep(1) client.dispatch_event(\"RESET_FOO\") connect Client.connect(self, port:int, hostname:str='localhost') -> None Open a connection to a PyGaSe server. This is a blocking function but can also be spawned as a coroutine or in a thread via Client.connect_in_thread() . Arguments port (int) : port number of the server to which to connect hostname (str) : hostname or IPv4 address of the server to which to connect connect_in_thread Client.connect_in_thread(self, port:int, hostname:str='localhost') -> threading.Thread Open a connection in a seperate thread. See Client.connect() . Returns threading.Thread : the thread the client loop runs in disconnect Client.disconnect(self, shutdown_server:bool=False) -> None Close the client connection. This method can also be spawned as a coroutine. shutdown_server (bool): wether or not the server should be shut down (only has an effect if the client has host permissions) access_game_state Client.access_game_state(self) Return a context manager to access the shared game state. Can be used in a with block to lock the synchronized game_state while working with it. Example with client.access_game_state() as game_state: do_stuff(game_state) wait_until Client.wait_until(self, game_state_condition, timeout:float=1.0) -> None Block until a condition on the game state is satisfied. Arguments game_state_condition (callable) : function that takes a pygase.GameState instance and returns a bool timeout (float) : time in seconds after which to raise a TimeoutError Raises TimeoutError : if the condition is not met after timeout seconds try_to Client.try_to(self, function, timeout:float=1.0) Execute a function using game state attributes that might not yet exist. This method repeatedly tries to execute function(game_state) , ignoring KeyError exceptions, until it either worksor times out. Arguments function (callable) : function that takes a pygase.GameState instance and returns anything timeout (float) : time in seconds after which to raise a TimeoutError Returns any : whatever function(game_state) returns Raises TimeoutError : if the function doesn't run through after timeout seconds dispatch_event Client.dispatch_event(self, event_type:str, *args, retries:int=0, ack_callback=None, **kwargs) -> None Send an event to the server. Arguments event_type (str) : event type identifier that links to a handler retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be invoked after the event was received Additional positional and keyword arguments will be sent as event data and passed to the handler function. ack_callback should not perform any long-running blocking operations (say a while True loop), as that will block the connections asynchronous event loop. Use a coroutine instead, with appropriately placed await s. register_event_handler Client.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for events of the given type pygase.backend Serve PyGaSe clients. Provides the Server class and all PyGaSe components that deal with progression and syncing of game states. Contents GameStateStore : main API class for game state repositories Server : main API class for PyGaSe servers GameStateMachine : main API class for game logic components Backend : main API class for a fully integrated PyGaSe backend GameStateStore GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None) Provide access to a game state and manage state updates. Arguments inital_game_state (GameState) : state of the game before the simulation begins get_update_cache GameStateStore.get_update_cache(self) -> list Return the latest state updates. get_game_state GameStateStore.get_game_state(self) -> pygase.gamestate.GameState Return the current game state. push_update GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -> None Push a new state update to the update cache. This method will usually be called by whatever is progressing the game state, usually a GameStateMachine . Server Server(self, game_state_store:pygase.backend.GameStateStore) Listen to clients and orchestrate the flow of events and state updates. The Server instance does not contain game logic or state, it is only responsible for connections to clients. The state is provided by a GameStateStore and game logic by a GameStateMachine . Arguments game_state_store (GameStateStore) : part of the backend that provides an interface to the pygase.GameState Attributes connections (list) : contains each clients address as a key leading to the corresponding pygase.connection.ServerConnection instance host_client (tuple) : address of the host client (who has permission to shutdown the server), if there is any game_state_store (GameStateStore) : game state repository Members hostname (str) : read-only access to the servers hostname port (int) : read-only access to the servers port number hostname Get the hostname or IP address on which the server listens. Returns None when the server is not running. port Get the port number on which the server listens. Returns None when the server is not running. run Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -> None Start the server under a specified address. This is a blocking function but can also be spawned as a coroutine or in a thread via Server.run_in_thread() . Arguments port (int) : port number the server will be bound to, default will be an available port chosen by the computers network controller hostname (str) : hostname or IP address the server will be bound to. Defaults to 'localhost' . event_wire (GameStateMachine) : object to which events are to be repeated (has to implement a _push_event(event) method and is typically a GameStateMachine ) run_in_thread Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -> threading.Thread Start the server in a seperate thread. See Server.run() . Returns threading.Thread : the thread the server loop runs in shutdown Server.shutdown(self) -> None Shut down the server. The server can be restarted via Server.run() in which case it will remember previous connections. This method can also be spawned as a coroutine. dispatch_event Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -> None Send an event to one or all clients. Arguments event_type (str) : identifies the event and links it to a handler target_client (tuple, str) : either 'all' for an event broadcast, or a clients address as a tuple retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be executed after the event was received and be passed a reference to the corresponding pygase.connection.ServerConnection instance Additional positional and keyword arguments will be sent as event data and passed to the clients handler function. register_event_handler Server.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for received events of the given type GameStateMachine GameStateMachine(self, game_state_store:pygase.backend.GameStateStore) Run a simulation that propagates the game state. A GameStateMachine progresses a game state through time, applying all game simulation logic. This class is meant either as a base class from which you inherit and implement the GameStateMachine.time_step() method, or you assign an implementation after instantiation. Arguments game_state_store (GameStateStore) : part of the PyGaSe backend that provides the state Attributes game_time (float) : duration the game has been running in seconds register_event_handler GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. For event handlers to have any effect, the events have to be wired from a Server to the GameStateMachine via the event_wire argument of the Server.run() method. Arguments event_type (str) : which type of event to link the handler function to handler_func (callable, coroutine) : function or coroutine to be invoked for events of the given type, gets passed the keyword argument game_state (along with those attached to the event) and is expected to return an update dict run_game_loop GameStateMachine.run_game_loop(self, interval:float=0.02) -> None Simulate the game world. This function blocks as it continously progresses the game state through time but it can also be spawned as a coroutine or in a thread via Server.run_game_loop_in_thread() . As long as the simulation is running, the game_state.status will be GameStatus.get('Active') . Arguments interval (float) : (minimum) duration in seconds between consecutive time steps run_game_loop_in_thread GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -> threading.Thread Simulate the game in a seperate thread. See GameStateMachine.run_game_loop() . Returns threading.Thread : the thread the game loop runs in stop GameStateMachine.stop(self, timeout:float=1.0) -> bool Pause the game simulation. This sets self.status to Gamestatus.get('Paused') . This method can also be spawned as a coroutine. A subsequent call of GameStateMachine.run_game_loop() will resume the simulation at the point where it was stopped. Arguments timeout (float) : time in seconds to wait for the simulation to stop Returns bool : wether or not the simulation was successfully stopped time_step GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -> dict Calculate a game state update. This method should be implemented to return a dict with all the updated state attributes. Arguments game_state (GameState) : the state of the game prior to the time step dt (float) : time in seconds since the last time step, use it to simulate at a consistent speed Returns dict : updated game state attributes Backend Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None) Easily create a fully integrated PyGaSe backend. Arguments initial_game_state (GameState) : state of the game before the simulation begins time_step_function (callable) : function that takes a game state and a time difference and returns a dict of updated game state attributes (see GameStateMachine.time_step() ) event_handlers (dict) : a dict with event types as keys and event handler functions as values Attributes game_state_store (GameStateStore) : the backends game state repository game_state_machine (GameStateMachine) : logic component that runs the game loop server (Server) : handles connections to PyGaSe clients Example # Run a game loop that continuously increments `foo` with velocity `bar`. Backend( initial_gamestate=GameState(foo=0.0, bar=0.5), time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt}, # Handle client events to reset `foo` and set a new `bar` value. event_handlers={ \"RESET_FOO\": lambda game_state, dt: {foo: 0.0}, \"SET_BAR\": lambda new_bar, game_state, dt: {bar: new_bar} } ).run(hostname=\"localhost\", port=8080) run Backend.run(self, hostname:str, port:int) Run state machine and server and bind the server to a given address. Arguments hostname (str) : hostname or IPv4 address the server will be bound to port (int) : port number the server will be bound to pygase.gamestate Customize a game state model and apply state updates. Contents TO_DELETE : 4 byte update marker for game state attributes that are to be deleted GameStatus : enum for the status of the game simulation GameState : class for serializable custom state data objects GameStateUpdate : class for serializable objects that express changes to a GameState object GameStatus GameStatus(self, /, *args, **kwargs) Enum for the game simulation status. 'Paused' 'Active' GameState GameState(self, time_order:int=0, game_status:int=0, **kwargs) Customize a serializable game state model. Contains game state information that will be synchronized between the server and the clients. Via pygase.utils.Sendable its instances will be serialized using the msgpack protocol and must only contain attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. Arguments time_order () : current time order number of the game state, higher means more recent game_status () : GameStatus enum value that describes whether or not the game loop is running Provide custom game state attributes via keyword arguments or assign them later. Attributes game_status () time_order () GameState instances mainly consist of custom attributes that make up the game state. is_paused GameState.is_paused(self) -> bool Return True if game is paused. GameStateUpdate GameStateUpdate(self, time_order:int, **kwargs) Update a GameState object. Contains a set of changes to carry out on a GameState . The server keeps a time_order counter and labels all updates in ascending order. Attributes of a GameStateUpdate object represent new values of GameState attributes. To remove game state attributes just assign TO_DELETE to it in the update. Use the + operator to add updates to one another and combine them or to add them to a game state in order to update it. Arguments time_order () : the time order up to which the update reaches game state attributes to be updated Attributes time_order () GameStateUpdate instances mainly consist of custom game state attributes to update. from_bytes GameStateUpdate.from_bytes(bytepack:bytes) -> 'GameStateUpdate' Extend Sendable.from_bytes to make sure time_order is of type Sqn . pygase.connection Provide low-level networking logic. This module is not supposed to be required by users of this library. Contents PROTOCOL_ID : 4 byte identifier for the PyGaSe package protocol ProtocolIDMismatchError : exception for receiving non-PyGaSe packages DuplicateSequenceError : exception for duplicate packages Header : class for PyGaSe package headers Package : class for PyGaSe UDP packages ClientPackage : subclass of Package for packages sent by clients ServerPackage : subclass of Package for packages sent by servers ConnectionStatus : enum for the status of a client-server connection Connection : class for the core network logic of client-server connections ClientConnection : subclass of Connection for the client side ServerConnection : subclass of Connectoin for the server side ProtocolIDMismatchError ProtocolIDMismatchError(self, /, *args, **kwargs) Bytestring could not be identified as a valid PyGaSe package. DuplicateSequenceError DuplicateSequenceError(self, /, *args, **kwargs) Received a package with a sequence number that was already received before. Header Header(self, sequence:int, ack:int, ack_bitfield:str) Create a PyGaSe package header. Arguments sequence (int) : package sequence number ack (int) : sequence number of the last received package ack_bitfield (str) : A 32 character string representing the 32 sequence numbers prior to the last one received, with the first character corresponding the packge directly preceding it and so forth. '1' means that package has been received, '0' means it hasn't. Attributes sequence (int) : see corresponding constructor argument ack (int) : see corresponding constructor argument ack_bitfield (str) : see corresponding constructor argument Sequence numbers : A sequence of 0 means no packages have been sent or received. After 65535 sequence numbers wrap around to 1, so they can be stored in 2 bytes. to_bytearray Header.to_bytearray(self) -> bytearray Return 12 bytes representing the header. destructure Header.destructure(self) -> tuple Return the tuple (sequence, ack, ack_bitfield) . deconstruct_datagram Header.deconstruct_datagram(datagram:bytes) -> tuple Return a tuple containing the header and the rest of the datagram. Arguments datagram (bytes) : serialized PyGaSe package to deconstruct Returns tuple : (header, payload) with payload being a bytestring of the rest of the datagram Package Package(self, header:pygase.connection.Header, events:list=None) Create a UDP package implementing the PyGaSe protocol. Arguments header (Header) : package header Arguments events (pygase.event.Event) : list events to attach to this package Attributes header (Header) : Members events (pygase.event.Event) : see corresponding constructor argument PyGaSe servers and clients use the subclasses ServerPackage and ClientPackage respectively. The Package class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state. events Get a list of the events in the package. add_event Package.add_event(self, event:pygase.event.Event) -> None Add a PyGaSe event to the package. Arguments event (pygase.event.Event) : the event to be attached to this package Raises OverflowError : if the package has previously been converted to a datagram and and its size with the added event would exceed Package._max_size (2048 bytex) get_bytesize Package.get_bytesize(self) -> int Return the size in bytes the package has as a datagram. to_datagram Package.to_datagram(self) -> bytes Return package compactly serialized to bytes . Raises OverflowError : if the resulting datagram would exceed Package._max_size from_datagram Package.from_datagram(datagram:bytes) -> 'Package' Deserialize datagram to Package . Arguments datagram (bytes) : bytestring to deserialize, typically received via network Returns Package : the deserialized package Raises ProtocolIDMismatchError : if the first four bytes don't match the PyGaSe protocol ID ClientPackage ClientPackage(self, header:pygase.connection.Header, time_order:int, events:list=None) Subclass of Package for packages sent by PyGaSe clients. Arguments time_order (int) : the clients last known time order of the game state Attributes time_order (int) : see corresponding constructor argument to_datagram ClientPackage.to_datagram(self) -> bytes Override Package.to_datagram to include time_order . from_datagram ClientPackage.from_datagram(datagram:bytes) -> 'ClientPackage' Override Package.from_datagram to include time_order . ServerPackage ServerPackage(self, header:pygase.connection.Header, game_state_update:pygase.gamestate.GameStateUpdate, events:list=None) Subclass of Package for packages sent by PyGaSe servers. Arguments game_state_update (pygase.gamestate.GameStateUpdate) : the servers most recent minimal update for the client to_datagram ServerPackage.to_datagram(self) -> bytes Override Package.to_datagram to include game_state_update . from_datagram ServerPackage.from_datagram(datagram:bytes) -> 'ServerPackage' Override Package.from_datagram to include game_state_update . ConnectionStatus ConnectionStatus(self, /, *args, **kwargs) Enum for the state of a connection. 'Disconnected' 'Connecting' 'Connected' Connection Connection(self, remote_address:tuple, event_handler, event_wire=None) Exchange packages between PyGaSe clients and servers. PyGaSe connections exchange events with their other side which are handled using custom handler functions. They also keep each other informed about which packages have been sent and received and automatically avoid network congestion. Arguments remote_address (tuple) : ('hostname', port) for the connection partner's address event_handler (pygase.event.UniversalEventHandler) : object that has a callable handle attribute that takes a pygase.event.Event as argument event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method) Attributes remote_address (tuple) : see corresponding constructor argument event_handler (pygase.event.UniversalEventHandler) : see corresponding constructor argument event_wire (pygase.GameStateMachine) : see corresponding constructor argument local_sequence (pygase.utils.Sqn) : sequence number of the last sent package remote_sequence (pygase.utils.Sqn) : sequence number of the last received package ack_bitfield (str) : acks for the 32 packages prior to self.remote_sequence latency (float) : the last registered RTT (round trip time) status (ConnectionStatus) : an integer value that informs about the state of the connections quality (str) : either 'good' or 'bad' depending on latency, used internally for congestion avoidance PyGaSe servers and clients use the subclasses ServerConnection and ClientConnection respectively. The Connection class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state. dispatch_event Connection.dispatch_event(self, event:pygase.event.Event, ack_callback=None, timeout_callback=None) Send an event to the connection partner. Arguments event (pygase.event.Event) : the event to dispatch ack_callback (callable, coroutine) : will be executed after the event was received timeout_callback (callable, coroutine) : will be executed if the event was not received Using long-running blocking operations in any of the callback functions can disturb the connection. ClientConnection ClientConnection(self, remote_address:tuple, event_handler) Subclass of Connection to describe the client side of a PyGaSe connection. Client connections hold a copy of the game state which is continously being updated according to state updates received from the server. Attributes game_state_context (pygase.utils.LockedRessource) : provides thread-safe access to a pygase.GameState shutdown ClientConnection.shutdown(self, shutdown_server:bool=False) Shut down the client connection. This method can also be spawned as a coroutine. Arguments shutdown_server (bool) : wether or not the server should be shut down too (only has an effect if the client has host permissions) loop ClientConnection.loop(self) Continously operate the connection. This method will keep sending and receiving packages and handling events until it is cancelled or the connection receives a shutdown command. It can also be spawned as a coroutine. ServerConnection ServerConnection(self, remote_address:tuple, event_handler, game_state_store, last_client_time_order:pygase.utils.Sqn, event_wire=None) Subclass of Connection that describes the server side of a PyGaSe connection. Arguments game_state_store (pygase.GameStateStore) : object that serves as an interface to the game state repository (has to provide the methods get_gamestate , get_update_cache and push_update ) last_client_time_order (pygase.utils.Sqn) : the last time order number known to the client Attributes game_state_store (pygase.GameStateStore) : see corresponding constructor argument last_client_time_order (pygase.utils.Sqn) : see corresponding constructor argument loop ServerConnection.loop(hostname:str, port:int, server, event_wire) -> None Continously orchestrate and operate connections to clients. This coroutine will keep listening for client packages, create new ServerConnection objects when necessary and make sure all packages are handled by and sent via the right connection. It will return as soon as the server receives a shutdown message. Arguments hostname (str) : the hostname or IPv4 address to which to bind the server socket port (int) : the port number to which to bind the server socket server (pygase.Server) : the server for which this loop is run event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method) pygase.event Handle events in PyGaSe clients, servers and state machines. Contains the basic components of the PyGaSe event framework. Contents Event : class for serializable event objects with event type and data UniversalEventHandler : class for components that can handle various event types Event Event(self, event_type:str, *args, **kwargs) Send PyGaSe events and attached data via UDP packages. Arguments event_type () : string that identifies the event and links it to a handler Arguments Additional positional arguments represent event data and will be passed to the handler function on the other side of the connection. keyword arguments to be passed to the handler function on the other side of the connection Attributes type () : handler_args () : handler_kwargs () : UniversalEventHandler UniversalEventHandler(self) Handle PyGaSe events with callback functions. register_event_handler UniversalEventHandler.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type () : string that identifies the events to be handled by this function event_handler_function () : callback function or coroutine that will be invoked with the handler args and kwargs with which the incoming event has been dispatched handle UniversalEventHandler.handle(self, event:pygase.event.Event, **kwargs) Invoke the appropriate handler function. Arguments event () : the event to be handled keyword arguments to be passed to the handler function (in addition to those already attached to the event) has_event_type UniversalEventHandler.has_event_type(self, event_type:str) -> bool Check if a handler was registered for event_type . pygase.utils Use helpful classes and functions. Provides utilities used in PyGaSe code or helpful to users of this library. Contents Comparable : mixin that makes object compare as equal if their type and attributes match Sendable : mixin that allows to serialize objects to small bytestrings NamedEnum : base class for lists of strings to be mapped to integer values Sqn : subclass of int for sequence numbers that always fit in 2 bytes LockedRessource : class that attaches a threading.Lock to a ressource get_available_ip_addresses : function that returns a list of local network interfaces Comparable Comparable(self, /, *args, **kwargs) Compare objects by equality of attributes. Sendable Sendable(self, /, *args, **kwargs) Send objects via UDP packages. This mixin for classes that are supposed to be sendable as part of a PyGaSe package makes objects serializable with the msgpack protocol. Sendables can only have attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. to_bytes Sendable.to_bytes(self) -> bytes Serialize the object to a compact bytestring. from_bytes Sendable.from_bytes(bytepack:bytes) Deserialize a bytestring into an instance of this class. Arguments bytepack () : the bytestring to be parsed to a subclass of Sendable Returns a copy of an object that was serialized via Sendable.to_bytes NamedEnum NamedEnum(self, /, *args, **kwargs) Map string labels to integer values. This is a base class meant to be subclassed to produce a dynamic enum mapping type. Example class MyEnum(NamedEnum): '''Encode labels in integers. - \"foo\" - \"bar\" ''' MyEnum.register(\"foo\") MyEnum.register(\"bar\") assert MyEnum.get(\"foo\") == 1 assert MyEnum.get(\"bar\") == 2 assert MyEnum.get(1) == \"foo\" assert MyEnum.get(2) == \"bar\" get NamedEnum.get(name_or_value) Get the value for a label or vice versa. Arguments name_or_value () : label or value to de- or encode Returns int value for given string label or vice versa Raises TypeError : if argument is neither int nor str register NamedEnum.register(name:str) -> None Add a new label to the mapping. Arguments name () : string label to register as new enum value Sqn Sqn(self, /, *args, **kwargs) Use finite periodic integers that fit in 2 bytes. Subclass of int that provides a residue-class-like behaviour of wrapping back to 1 after a maximum value. Use it to represent sequence numbers with a fixed number of bytes when you only need well-defined ordering within a specific finite scale. 0 represents the state before the sequence has started. For the default bytesize of 2 the maximum sequence number is 65535. set_bytesize Sqn.set_bytesize(bytesize:int) -> None Redefine the bytesize and wrap-over behaviour for all Sqn instances. Arguments bytesize () : new size for the bytes representation of Sqn instances get_max_sequence Sqn.get_max_sequence() -> int Return the maximum sequence number after which Sqn s wrap back to 1. to_sqn_bytes Sqn.to_sqn_bytes(self) -> bytes Return representation of the number in exactly the currenly set bytesize. The default bytesize is 2. from_sqn_bytes Sqn.from_sqn_bytes(bytestring:bytes) -> 'Sqn' Return Sqn object that was encoded in given bytestring. LockedRessource LockedRessource(self, ressource) Access a ressource thread-safely. This class makes an object available via a context manager that essentialy attaches a threading.Lock to it, that threads writing to this object should abide. Usage example: myRessource = { 'foo': 'bar' } myLockedRessource = LockedRessource(myRessource) with myLockedRessource() as ressource: # do stuff without any other threads meddling with the ressource Arguments ressource () : object to be wrapped Attributes lock () : threading.Lock that threads writing to ressource should abide. ressource () get_available_ip_addresses get_available_ip_addresses() -> list Return a list of all locally available IPv4 addresses.","title":"pygase.client"},{"location":"api/low-level/#pygaseclient","text":"Connect to PyGaSe servers. Contents Client : main API class for PyGaSe clients","title":"pygase.client"},{"location":"api/low-level/#client","text":"Client(self) Exchange events with a PyGaSe server and access a synchronized game state. Attributes connection (pygase.connection.ClientConnection) : object that contains all networking information Example from time import sleep # Connect a client to the server from the Backend code example client = Client() client.connect_in_thread(hostname=\"localhost\", port=8080) # Increase `bar` five times, then reset `foo` for i in range(5): client.dispatch_event(\"SET_BAR\", new_bar=i) sleep(1) client.dispatch_event(\"RESET_FOO\")","title":"Client"},{"location":"api/low-level/#connect","text":"Client.connect(self, port:int, hostname:str='localhost') -> None Open a connection to a PyGaSe server. This is a blocking function but can also be spawned as a coroutine or in a thread via Client.connect_in_thread() . Arguments port (int) : port number of the server to which to connect hostname (str) : hostname or IPv4 address of the server to which to connect","title":"connect"},{"location":"api/low-level/#connect_in_thread","text":"Client.connect_in_thread(self, port:int, hostname:str='localhost') -> threading.Thread Open a connection in a seperate thread. See Client.connect() . Returns threading.Thread : the thread the client loop runs in","title":"connect_in_thread"},{"location":"api/low-level/#disconnect","text":"Client.disconnect(self, shutdown_server:bool=False) -> None Close the client connection. This method can also be spawned as a coroutine. shutdown_server (bool): wether or not the server should be shut down (only has an effect if the client has host permissions)","title":"disconnect"},{"location":"api/low-level/#access_game_state","text":"Client.access_game_state(self) Return a context manager to access the shared game state. Can be used in a with block to lock the synchronized game_state while working with it. Example with client.access_game_state() as game_state: do_stuff(game_state)","title":"access_game_state"},{"location":"api/low-level/#wait_until","text":"Client.wait_until(self, game_state_condition, timeout:float=1.0) -> None Block until a condition on the game state is satisfied. Arguments game_state_condition (callable) : function that takes a pygase.GameState instance and returns a bool timeout (float) : time in seconds after which to raise a TimeoutError Raises TimeoutError : if the condition is not met after timeout seconds","title":"wait_until"},{"location":"api/low-level/#try_to","text":"Client.try_to(self, function, timeout:float=1.0) Execute a function using game state attributes that might not yet exist. This method repeatedly tries to execute function(game_state) , ignoring KeyError exceptions, until it either worksor times out. Arguments function (callable) : function that takes a pygase.GameState instance and returns anything timeout (float) : time in seconds after which to raise a TimeoutError Returns any : whatever function(game_state) returns Raises TimeoutError : if the function doesn't run through after timeout seconds","title":"try_to"},{"location":"api/low-level/#dispatch_event","text":"Client.dispatch_event(self, event_type:str, *args, retries:int=0, ack_callback=None, **kwargs) -> None Send an event to the server. Arguments event_type (str) : event type identifier that links to a handler retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be invoked after the event was received Additional positional and keyword arguments will be sent as event data and passed to the handler function. ack_callback should not perform any long-running blocking operations (say a while True loop), as that will block the connections asynchronous event loop. Use a coroutine instead, with appropriately placed await s.","title":"dispatch_event"},{"location":"api/low-level/#register_event_handler","text":"Client.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for events of the given type","title":"register_event_handler"},{"location":"api/low-level/#pygasebackend","text":"Serve PyGaSe clients. Provides the Server class and all PyGaSe components that deal with progression and syncing of game states. Contents GameStateStore : main API class for game state repositories Server : main API class for PyGaSe servers GameStateMachine : main API class for game logic components Backend : main API class for a fully integrated PyGaSe backend","title":"pygase.backend"},{"location":"api/low-level/#gamestatestore","text":"GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None) Provide access to a game state and manage state updates. Arguments inital_game_state (GameState) : state of the game before the simulation begins","title":"GameStateStore"},{"location":"api/low-level/#get_update_cache","text":"GameStateStore.get_update_cache(self) -> list Return the latest state updates.","title":"get_update_cache"},{"location":"api/low-level/#get_game_state","text":"GameStateStore.get_game_state(self) -> pygase.gamestate.GameState Return the current game state.","title":"get_game_state"},{"location":"api/low-level/#push_update","text":"GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -> None Push a new state update to the update cache. This method will usually be called by whatever is progressing the game state, usually a GameStateMachine .","title":"push_update"},{"location":"api/low-level/#server","text":"Server(self, game_state_store:pygase.backend.GameStateStore) Listen to clients and orchestrate the flow of events and state updates. The Server instance does not contain game logic or state, it is only responsible for connections to clients. The state is provided by a GameStateStore and game logic by a GameStateMachine . Arguments game_state_store (GameStateStore) : part of the backend that provides an interface to the pygase.GameState Attributes connections (list) : contains each clients address as a key leading to the corresponding pygase.connection.ServerConnection instance host_client (tuple) : address of the host client (who has permission to shutdown the server), if there is any game_state_store (GameStateStore) : game state repository Members hostname (str) : read-only access to the servers hostname port (int) : read-only access to the servers port number","title":"Server"},{"location":"api/low-level/#hostname","text":"Get the hostname or IP address on which the server listens. Returns None when the server is not running.","title":"hostname"},{"location":"api/low-level/#port","text":"Get the port number on which the server listens. Returns None when the server is not running.","title":"port"},{"location":"api/low-level/#run","text":"Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -> None Start the server under a specified address. This is a blocking function but can also be spawned as a coroutine or in a thread via Server.run_in_thread() . Arguments port (int) : port number the server will be bound to, default will be an available port chosen by the computers network controller hostname (str) : hostname or IP address the server will be bound to. Defaults to 'localhost' . event_wire (GameStateMachine) : object to which events are to be repeated (has to implement a _push_event(event) method and is typically a GameStateMachine )","title":"run"},{"location":"api/low-level/#run_in_thread","text":"Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -> threading.Thread Start the server in a seperate thread. See Server.run() . Returns threading.Thread : the thread the server loop runs in","title":"run_in_thread"},{"location":"api/low-level/#shutdown","text":"Server.shutdown(self) -> None Shut down the server. The server can be restarted via Server.run() in which case it will remember previous connections. This method can also be spawned as a coroutine.","title":"shutdown"},{"location":"api/low-level/#dispatch_event_1","text":"Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -> None Send an event to one or all clients. Arguments event_type (str) : identifies the event and links it to a handler target_client (tuple, str) : either 'all' for an event broadcast, or a clients address as a tuple retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be executed after the event was received and be passed a reference to the corresponding pygase.connection.ServerConnection instance Additional positional and keyword arguments will be sent as event data and passed to the clients handler function.","title":"dispatch_event"},{"location":"api/low-level/#register_event_handler_1","text":"Server.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for received events of the given type","title":"register_event_handler"},{"location":"api/low-level/#gamestatemachine","text":"GameStateMachine(self, game_state_store:pygase.backend.GameStateStore) Run a simulation that propagates the game state. A GameStateMachine progresses a game state through time, applying all game simulation logic. This class is meant either as a base class from which you inherit and implement the GameStateMachine.time_step() method, or you assign an implementation after instantiation. Arguments game_state_store (GameStateStore) : part of the PyGaSe backend that provides the state Attributes game_time (float) : duration the game has been running in seconds","title":"GameStateMachine"},{"location":"api/low-level/#register_event_handler_2","text":"GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. For event handlers to have any effect, the events have to be wired from a Server to the GameStateMachine via the event_wire argument of the Server.run() method. Arguments event_type (str) : which type of event to link the handler function to handler_func (callable, coroutine) : function or coroutine to be invoked for events of the given type, gets passed the keyword argument game_state (along with those attached to the event) and is expected to return an update dict","title":"register_event_handler"},{"location":"api/low-level/#run_game_loop","text":"GameStateMachine.run_game_loop(self, interval:float=0.02) -> None Simulate the game world. This function blocks as it continously progresses the game state through time but it can also be spawned as a coroutine or in a thread via Server.run_game_loop_in_thread() . As long as the simulation is running, the game_state.status will be GameStatus.get('Active') . Arguments interval (float) : (minimum) duration in seconds between consecutive time steps","title":"run_game_loop"},{"location":"api/low-level/#run_game_loop_in_thread","text":"GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -> threading.Thread Simulate the game in a seperate thread. See GameStateMachine.run_game_loop() . Returns threading.Thread : the thread the game loop runs in","title":"run_game_loop_in_thread"},{"location":"api/low-level/#stop","text":"GameStateMachine.stop(self, timeout:float=1.0) -> bool Pause the game simulation. This sets self.status to Gamestatus.get('Paused') . This method can also be spawned as a coroutine. A subsequent call of GameStateMachine.run_game_loop() will resume the simulation at the point where it was stopped. Arguments timeout (float) : time in seconds to wait for the simulation to stop Returns bool : wether or not the simulation was successfully stopped","title":"stop"},{"location":"api/low-level/#time_step","text":"GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -> dict Calculate a game state update. This method should be implemented to return a dict with all the updated state attributes. Arguments game_state (GameState) : the state of the game prior to the time step dt (float) : time in seconds since the last time step, use it to simulate at a consistent speed Returns dict : updated game state attributes","title":"time_step"},{"location":"api/low-level/#backend","text":"Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None) Easily create a fully integrated PyGaSe backend. Arguments initial_game_state (GameState) : state of the game before the simulation begins time_step_function (callable) : function that takes a game state and a time difference and returns a dict of updated game state attributes (see GameStateMachine.time_step() ) event_handlers (dict) : a dict with event types as keys and event handler functions as values Attributes game_state_store (GameStateStore) : the backends game state repository game_state_machine (GameStateMachine) : logic component that runs the game loop server (Server) : handles connections to PyGaSe clients Example # Run a game loop that continuously increments `foo` with velocity `bar`. Backend( initial_gamestate=GameState(foo=0.0, bar=0.5), time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt}, # Handle client events to reset `foo` and set a new `bar` value. event_handlers={ \"RESET_FOO\": lambda game_state, dt: {foo: 0.0}, \"SET_BAR\": lambda new_bar, game_state, dt: {bar: new_bar} } ).run(hostname=\"localhost\", port=8080)","title":"Backend"},{"location":"api/low-level/#run_1","text":"Backend.run(self, hostname:str, port:int) Run state machine and server and bind the server to a given address. Arguments hostname (str) : hostname or IPv4 address the server will be bound to port (int) : port number the server will be bound to","title":"run"},{"location":"api/low-level/#pygasegamestate","text":"Customize a game state model and apply state updates.","title":"pygase.gamestate"},{"location":"api/low-level/#contents","text":"TO_DELETE : 4 byte update marker for game state attributes that are to be deleted GameStatus : enum for the status of the game simulation GameState : class for serializable custom state data objects GameStateUpdate : class for serializable objects that express changes to a GameState object","title":"Contents"},{"location":"api/low-level/#gamestatus","text":"GameStatus(self, /, *args, **kwargs) Enum for the game simulation status. 'Paused' 'Active'","title":"GameStatus"},{"location":"api/low-level/#gamestate","text":"GameState(self, time_order:int=0, game_status:int=0, **kwargs) Customize a serializable game state model. Contains game state information that will be synchronized between the server and the clients. Via pygase.utils.Sendable its instances will be serialized using the msgpack protocol and must only contain attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. Arguments time_order () : current time order number of the game state, higher means more recent game_status () : GameStatus enum value that describes whether or not the game loop is running Provide custom game state attributes via keyword arguments or assign them later. Attributes game_status () time_order () GameState instances mainly consist of custom attributes that make up the game state.","title":"GameState"},{"location":"api/low-level/#is_paused","text":"GameState.is_paused(self) -> bool Return True if game is paused.","title":"is_paused"},{"location":"api/low-level/#gamestateupdate","text":"GameStateUpdate(self, time_order:int, **kwargs) Update a GameState object. Contains a set of changes to carry out on a GameState . The server keeps a time_order counter and labels all updates in ascending order. Attributes of a GameStateUpdate object represent new values of GameState attributes. To remove game state attributes just assign TO_DELETE to it in the update. Use the + operator to add updates to one another and combine them or to add them to a game state in order to update it. Arguments time_order () : the time order up to which the update reaches game state attributes to be updated Attributes time_order () GameStateUpdate instances mainly consist of custom game state attributes to update.","title":"GameStateUpdate"},{"location":"api/low-level/#from_bytes","text":"GameStateUpdate.from_bytes(bytepack:bytes) -> 'GameStateUpdate' Extend Sendable.from_bytes to make sure time_order is of type Sqn .","title":"from_bytes"},{"location":"api/low-level/#pygaseconnection","text":"Provide low-level networking logic. This module is not supposed to be required by users of this library. Contents PROTOCOL_ID : 4 byte identifier for the PyGaSe package protocol ProtocolIDMismatchError : exception for receiving non-PyGaSe packages DuplicateSequenceError : exception for duplicate packages Header : class for PyGaSe package headers Package : class for PyGaSe UDP packages ClientPackage : subclass of Package for packages sent by clients ServerPackage : subclass of Package for packages sent by servers ConnectionStatus : enum for the status of a client-server connection Connection : class for the core network logic of client-server connections ClientConnection : subclass of Connection for the client side ServerConnection : subclass of Connectoin for the server side","title":"pygase.connection"},{"location":"api/low-level/#protocolidmismatcherror","text":"ProtocolIDMismatchError(self, /, *args, **kwargs) Bytestring could not be identified as a valid PyGaSe package.","title":"ProtocolIDMismatchError"},{"location":"api/low-level/#duplicatesequenceerror","text":"DuplicateSequenceError(self, /, *args, **kwargs) Received a package with a sequence number that was already received before.","title":"DuplicateSequenceError"},{"location":"api/low-level/#header","text":"Header(self, sequence:int, ack:int, ack_bitfield:str) Create a PyGaSe package header. Arguments sequence (int) : package sequence number ack (int) : sequence number of the last received package ack_bitfield (str) : A 32 character string representing the 32 sequence numbers prior to the last one received, with the first character corresponding the packge directly preceding it and so forth. '1' means that package has been received, '0' means it hasn't. Attributes sequence (int) : see corresponding constructor argument ack (int) : see corresponding constructor argument ack_bitfield (str) : see corresponding constructor argument Sequence numbers : A sequence of 0 means no packages have been sent or received. After 65535 sequence numbers wrap around to 1, so they can be stored in 2 bytes.","title":"Header"},{"location":"api/low-level/#to_bytearray","text":"Header.to_bytearray(self) -> bytearray Return 12 bytes representing the header.","title":"to_bytearray"},{"location":"api/low-level/#destructure","text":"Header.destructure(self) -> tuple Return the tuple (sequence, ack, ack_bitfield) .","title":"destructure"},{"location":"api/low-level/#deconstruct_datagram","text":"Header.deconstruct_datagram(datagram:bytes) -> tuple Return a tuple containing the header and the rest of the datagram. Arguments datagram (bytes) : serialized PyGaSe package to deconstruct Returns tuple : (header, payload) with payload being a bytestring of the rest of the datagram","title":"deconstruct_datagram"},{"location":"api/low-level/#package","text":"Package(self, header:pygase.connection.Header, events:list=None) Create a UDP package implementing the PyGaSe protocol. Arguments header (Header) : package header Arguments events (pygase.event.Event) : list events to attach to this package Attributes header (Header) : Members events (pygase.event.Event) : see corresponding constructor argument PyGaSe servers and clients use the subclasses ServerPackage and ClientPackage respectively. The Package class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state.","title":"Package"},{"location":"api/low-level/#events","text":"Get a list of the events in the package.","title":"events"},{"location":"api/low-level/#add_event","text":"Package.add_event(self, event:pygase.event.Event) -> None Add a PyGaSe event to the package. Arguments event (pygase.event.Event) : the event to be attached to this package Raises OverflowError : if the package has previously been converted to a datagram and and its size with the added event would exceed Package._max_size (2048 bytex)","title":"add_event"},{"location":"api/low-level/#get_bytesize","text":"Package.get_bytesize(self) -> int Return the size in bytes the package has as a datagram.","title":"get_bytesize"},{"location":"api/low-level/#to_datagram","text":"Package.to_datagram(self) -> bytes Return package compactly serialized to bytes . Raises OverflowError : if the resulting datagram would exceed Package._max_size","title":"to_datagram"},{"location":"api/low-level/#from_datagram","text":"Package.from_datagram(datagram:bytes) -> 'Package' Deserialize datagram to Package . Arguments datagram (bytes) : bytestring to deserialize, typically received via network Returns Package : the deserialized package Raises ProtocolIDMismatchError : if the first four bytes don't match the PyGaSe protocol ID","title":"from_datagram"},{"location":"api/low-level/#clientpackage","text":"ClientPackage(self, header:pygase.connection.Header, time_order:int, events:list=None) Subclass of Package for packages sent by PyGaSe clients. Arguments time_order (int) : the clients last known time order of the game state Attributes time_order (int) : see corresponding constructor argument","title":"ClientPackage"},{"location":"api/low-level/#to_datagram_1","text":"ClientPackage.to_datagram(self) -> bytes Override Package.to_datagram to include time_order .","title":"to_datagram"},{"location":"api/low-level/#from_datagram_1","text":"ClientPackage.from_datagram(datagram:bytes) -> 'ClientPackage' Override Package.from_datagram to include time_order .","title":"from_datagram"},{"location":"api/low-level/#serverpackage","text":"ServerPackage(self, header:pygase.connection.Header, game_state_update:pygase.gamestate.GameStateUpdate, events:list=None) Subclass of Package for packages sent by PyGaSe servers. Arguments game_state_update (pygase.gamestate.GameStateUpdate) : the servers most recent minimal update for the client","title":"ServerPackage"},{"location":"api/low-level/#to_datagram_2","text":"ServerPackage.to_datagram(self) -> bytes Override Package.to_datagram to include game_state_update .","title":"to_datagram"},{"location":"api/low-level/#from_datagram_2","text":"ServerPackage.from_datagram(datagram:bytes) -> 'ServerPackage' Override Package.from_datagram to include game_state_update .","title":"from_datagram"},{"location":"api/low-level/#connectionstatus","text":"ConnectionStatus(self, /, *args, **kwargs) Enum for the state of a connection. 'Disconnected' 'Connecting' 'Connected'","title":"ConnectionStatus"},{"location":"api/low-level/#connection","text":"Connection(self, remote_address:tuple, event_handler, event_wire=None) Exchange packages between PyGaSe clients and servers. PyGaSe connections exchange events with their other side which are handled using custom handler functions. They also keep each other informed about which packages have been sent and received and automatically avoid network congestion. Arguments remote_address (tuple) : ('hostname', port) for the connection partner's address event_handler (pygase.event.UniversalEventHandler) : object that has a callable handle attribute that takes a pygase.event.Event as argument event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method) Attributes remote_address (tuple) : see corresponding constructor argument event_handler (pygase.event.UniversalEventHandler) : see corresponding constructor argument event_wire (pygase.GameStateMachine) : see corresponding constructor argument local_sequence (pygase.utils.Sqn) : sequence number of the last sent package remote_sequence (pygase.utils.Sqn) : sequence number of the last received package ack_bitfield (str) : acks for the 32 packages prior to self.remote_sequence latency (float) : the last registered RTT (round trip time) status (ConnectionStatus) : an integer value that informs about the state of the connections quality (str) : either 'good' or 'bad' depending on latency, used internally for congestion avoidance PyGaSe servers and clients use the subclasses ServerConnection and ClientConnection respectively. The Connection class would also work on its own (it's not an 'abstract' class), in which case you would have all features of PyGaSe except for a synchronized game state.","title":"Connection"},{"location":"api/low-level/#dispatch_event_2","text":"Connection.dispatch_event(self, event:pygase.event.Event, ack_callback=None, timeout_callback=None) Send an event to the connection partner. Arguments event (pygase.event.Event) : the event to dispatch ack_callback (callable, coroutine) : will be executed after the event was received timeout_callback (callable, coroutine) : will be executed if the event was not received Using long-running blocking operations in any of the callback functions can disturb the connection.","title":"dispatch_event"},{"location":"api/low-level/#clientconnection","text":"ClientConnection(self, remote_address:tuple, event_handler) Subclass of Connection to describe the client side of a PyGaSe connection. Client connections hold a copy of the game state which is continously being updated according to state updates received from the server. Attributes game_state_context (pygase.utils.LockedRessource) : provides thread-safe access to a pygase.GameState","title":"ClientConnection"},{"location":"api/low-level/#shutdown_1","text":"ClientConnection.shutdown(self, shutdown_server:bool=False) Shut down the client connection. This method can also be spawned as a coroutine. Arguments shutdown_server (bool) : wether or not the server should be shut down too (only has an effect if the client has host permissions)","title":"shutdown"},{"location":"api/low-level/#loop","text":"ClientConnection.loop(self) Continously operate the connection. This method will keep sending and receiving packages and handling events until it is cancelled or the connection receives a shutdown command. It can also be spawned as a coroutine.","title":"loop"},{"location":"api/low-level/#serverconnection","text":"ServerConnection(self, remote_address:tuple, event_handler, game_state_store, last_client_time_order:pygase.utils.Sqn, event_wire=None) Subclass of Connection that describes the server side of a PyGaSe connection. Arguments game_state_store (pygase.GameStateStore) : object that serves as an interface to the game state repository (has to provide the methods get_gamestate , get_update_cache and push_update ) last_client_time_order (pygase.utils.Sqn) : the last time order number known to the client Attributes game_state_store (pygase.GameStateStore) : see corresponding constructor argument last_client_time_order (pygase.utils.Sqn) : see corresponding constructor argument","title":"ServerConnection"},{"location":"api/low-level/#loop_1","text":"ServerConnection.loop(hostname:str, port:int, server, event_wire) -> None Continously orchestrate and operate connections to clients. This coroutine will keep listening for client packages, create new ServerConnection objects when necessary and make sure all packages are handled by and sent via the right connection. It will return as soon as the server receives a shutdown message. Arguments hostname (str) : the hostname or IPv4 address to which to bind the server socket port (int) : the port number to which to bind the server socket server (pygase.Server) : the server for which this loop is run event_wire (pygase.GameStateMachine) : object to which events are to be repeated (has to implement a _push_event method)","title":"loop"},{"location":"api/low-level/#pygaseevent","text":"Handle events in PyGaSe clients, servers and state machines. Contains the basic components of the PyGaSe event framework.","title":"pygase.event"},{"location":"api/low-level/#contents_1","text":"Event : class for serializable event objects with event type and data UniversalEventHandler : class for components that can handle various event types","title":"Contents"},{"location":"api/low-level/#event","text":"Event(self, event_type:str, *args, **kwargs) Send PyGaSe events and attached data via UDP packages. Arguments event_type () : string that identifies the event and links it to a handler Arguments Additional positional arguments represent event data and will be passed to the handler function on the other side of the connection. keyword arguments to be passed to the handler function on the other side of the connection Attributes type () : handler_args () : handler_kwargs () :","title":"Event"},{"location":"api/low-level/#universaleventhandler","text":"UniversalEventHandler(self) Handle PyGaSe events with callback functions.","title":"UniversalEventHandler"},{"location":"api/low-level/#register_event_handler_3","text":"UniversalEventHandler.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type () : string that identifies the events to be handled by this function event_handler_function () : callback function or coroutine that will be invoked with the handler args and kwargs with which the incoming event has been dispatched","title":"register_event_handler"},{"location":"api/low-level/#handle","text":"UniversalEventHandler.handle(self, event:pygase.event.Event, **kwargs) Invoke the appropriate handler function. Arguments event () : the event to be handled keyword arguments to be passed to the handler function (in addition to those already attached to the event)","title":"handle"},{"location":"api/low-level/#has_event_type","text":"UniversalEventHandler.has_event_type(self, event_type:str) -> bool Check if a handler was registered for event_type .","title":"has_event_type"},{"location":"api/low-level/#pygaseutils","text":"Use helpful classes and functions. Provides utilities used in PyGaSe code or helpful to users of this library.","title":"pygase.utils"},{"location":"api/low-level/#contents_2","text":"Comparable : mixin that makes object compare as equal if their type and attributes match Sendable : mixin that allows to serialize objects to small bytestrings NamedEnum : base class for lists of strings to be mapped to integer values Sqn : subclass of int for sequence numbers that always fit in 2 bytes LockedRessource : class that attaches a threading.Lock to a ressource get_available_ip_addresses : function that returns a list of local network interfaces","title":"Contents"},{"location":"api/low-level/#comparable","text":"Comparable(self, /, *args, **kwargs) Compare objects by equality of attributes.","title":"Comparable"},{"location":"api/low-level/#sendable","text":"Sendable(self, /, *args, **kwargs) Send objects via UDP packages. This mixin for classes that are supposed to be sendable as part of a PyGaSe package makes objects serializable with the msgpack protocol. Sendables can only have attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such.","title":"Sendable"},{"location":"api/low-level/#to_bytes","text":"Sendable.to_bytes(self) -> bytes Serialize the object to a compact bytestring.","title":"to_bytes"},{"location":"api/low-level/#from_bytes_1","text":"Sendable.from_bytes(bytepack:bytes) Deserialize a bytestring into an instance of this class. Arguments bytepack () : the bytestring to be parsed to a subclass of Sendable Returns a copy of an object that was serialized via Sendable.to_bytes","title":"from_bytes"},{"location":"api/low-level/#namedenum","text":"NamedEnum(self, /, *args, **kwargs) Map string labels to integer values. This is a base class meant to be subclassed to produce a dynamic enum mapping type. Example class MyEnum(NamedEnum): '''Encode labels in integers. - \"foo\" - \"bar\" ''' MyEnum.register(\"foo\") MyEnum.register(\"bar\") assert MyEnum.get(\"foo\") == 1 assert MyEnum.get(\"bar\") == 2 assert MyEnum.get(1) == \"foo\" assert MyEnum.get(2) == \"bar\"","title":"NamedEnum"},{"location":"api/low-level/#get","text":"NamedEnum.get(name_or_value) Get the value for a label or vice versa. Arguments name_or_value () : label or value to de- or encode Returns int value for given string label or vice versa Raises TypeError : if argument is neither int nor str","title":"get"},{"location":"api/low-level/#register","text":"NamedEnum.register(name:str) -> None Add a new label to the mapping. Arguments name () : string label to register as new enum value","title":"register"},{"location":"api/low-level/#sqn","text":"Sqn(self, /, *args, **kwargs) Use finite periodic integers that fit in 2 bytes. Subclass of int that provides a residue-class-like behaviour of wrapping back to 1 after a maximum value. Use it to represent sequence numbers with a fixed number of bytes when you only need well-defined ordering within a specific finite scale. 0 represents the state before the sequence has started. For the default bytesize of 2 the maximum sequence number is 65535.","title":"Sqn"},{"location":"api/low-level/#set_bytesize","text":"Sqn.set_bytesize(bytesize:int) -> None Redefine the bytesize and wrap-over behaviour for all Sqn instances. Arguments bytesize () : new size for the bytes representation of Sqn instances","title":"set_bytesize"},{"location":"api/low-level/#get_max_sequence","text":"Sqn.get_max_sequence() -> int Return the maximum sequence number after which Sqn s wrap back to 1.","title":"get_max_sequence"},{"location":"api/low-level/#to_sqn_bytes","text":"Sqn.to_sqn_bytes(self) -> bytes Return representation of the number in exactly the currenly set bytesize. The default bytesize is 2.","title":"to_sqn_bytes"},{"location":"api/low-level/#from_sqn_bytes","text":"Sqn.from_sqn_bytes(bytestring:bytes) -> 'Sqn' Return Sqn object that was encoded in given bytestring.","title":"from_sqn_bytes"},{"location":"api/low-level/#lockedressource","text":"LockedRessource(self, ressource) Access a ressource thread-safely. This class makes an object available via a context manager that essentialy attaches a threading.Lock to it, that threads writing to this object should abide. Usage example: myRessource = { 'foo': 'bar' } myLockedRessource = LockedRessource(myRessource) with myLockedRessource() as ressource: # do stuff without any other threads meddling with the ressource Arguments ressource () : object to be wrapped Attributes lock () : threading.Lock that threads writing to ressource should abide. ressource ()","title":"LockedRessource"},{"location":"api/low-level/#get_available_ip_addresses","text":"get_available_ip_addresses() -> list Return a list of all locally available IPv4 addresses.","title":"get_available_ip_addresses"},{"location":"api/main/","text":"pygase Create smooth and scalable online and LAN multiplayer games easily. PyGaSe, or Python Game Server, is a library (or framework, whichever term you prefer) that provides a complete set of high-level components for real-time networking for games. As a user of this library you will only need classes and functions directly imported from pygase : # For clients: from pygase import Client # For backends: from pygase import GameState, GameStateStore, GameStateMachine, Server # Not necessary but might come in handy: from pygase import get_availabe_ip_addresses GameState GameState(self, time_order:int=0, game_status:int=0, **kwargs) Customize a serializable game state model. Contains game state information that will be synchronized between the server and the clients. Via pygase.utils.Sendable its instances will be serialized using the msgpack protocol and must only contain attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. Arguments time_order () : current time order number of the game state, higher means more recent game_status () : GameStatus enum value that describes whether or not the game loop is running Provide custom game state attributes via keyword arguments or assign them later. Attributes game_status () time_order () GameState instances mainly consist of custom attributes that make up the game state. is_paused GameState.is_paused(self) -> bool Return True if game is paused. Backend Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None) Easily create a fully integrated PyGaSe backend. Arguments initial_game_state (GameState) : state of the game before the simulation begins time_step_function (callable) : function that takes a game state and a time difference and returns a dict of updated game state attributes (see GameStateMachine.time_step() ) event_handlers (dict) : a dict with event types as keys and event handler functions as values Attributes game_state_store (GameStateStore) : the backends game state repository game_state_machine (GameStateMachine) : logic component that runs the game loop server (Server) : handles connections to PyGaSe clients Example # Run a game loop that continuously increments `foo` with velocity `bar`. Backend( initial_gamestate=GameState(foo=0.0, bar=0.5), time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt}, # Handle client events to reset `foo` and set a new `bar` value. event_handlers={ \"RESET_FOO\": lambda game_state, dt: {foo: 0.0}, \"SET_BAR\": lambda new_bar, game_state, dt: {bar: new_bar} } ).run(hostname=\"localhost\", port=8080) run Backend.run(self, hostname:str, port:int) Run state machine and server and bind the server to a given address. Arguments hostname (str) : hostname or IPv4 address the server will be bound to port (int) : port number the server will be bound to shutdown Backend.shutdown(self) Shut down server and stop game loop. GameStateStore GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None) Provide access to a game state and manage state updates. Arguments inital_game_state (GameState) : state of the game before the simulation begins Raises TypeError : if 'initial_game_state' is not an instance of GameState get_update_cache GameStateStore.get_update_cache(self) -> list Return the latest state updates. get_game_state GameStateStore.get_game_state(self) -> pygase.gamestate.GameState Return the current game state. push_update GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -> None Push a new state update to the update cache. This method will usually be called by whatever is progressing the game state, usually a GameStateMachine . GameStateMachine GameStateMachine(self, game_state_store:pygase.backend.GameStateStore) Run a simulation that propagates the game state. A GameStateMachine progresses a game state through time, applying all game simulation logic. This class is meant either as a base class from which you inherit and implement the GameStateMachine.time_step() method, or you assign an implementation after instantiation. Arguments game_state_store (GameStateStore) : part of the PyGaSe backend that provides the state Attributes game_time (float) : duration the game has been running in seconds register_event_handler GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. For event handlers to have any effect, the events have to be wired from a Server to the GameStateMachine via the event_wire argument of the Server.run() method. Arguments event_type (str) : which type of event to link the handler function to handler_func (callable, coroutine) : function or coroutine to be invoked for events of the given type In addition to the event data, a GameStateMachine #s handler function gets passed - the following keyword arguments : - - game_state : game state at the time of the event - - dt : time since the last time step - - client_address : client which sent the event that is being handled It is expected to return an update dict like the time_step method. run_game_loop GameStateMachine.run_game_loop(self, interval:float=0.02) -> None Simulate the game world. This function blocks as it continously progresses the game state through time but it can also be spawned as a coroutine or in a thread via Server.run_game_loop_in_thread() . As long as the simulation is running, the game_state.status will be GameStatus.get('Active') . Arguments interval (float) : (minimum) duration in seconds between consecutive time steps run_game_loop_in_thread GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -> threading.Thread Simulate the game in a seperate thread. See GameStateMachine.run_game_loop() . Returns threading.Thread : the thread the game loop runs in stop GameStateMachine.stop(self, timeout:float=1.0) -> bool Pause the game simulation. This sets self.status to Gamestatus.get('Paused') . This method can also be spawned as a coroutine. A subsequent call of GameStateMachine.run_game_loop() will resume the simulation at the point where it was stopped. Arguments timeout (float) : time in seconds to wait for the simulation to stop Returns bool : wether or not the simulation was successfully stopped time_step GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -> dict Calculate a game state update. This method should be implemented to return a dict with all the updated state attributes. Arguments game_state (GameState) : the state of the game prior to the time step dt (float) : time in seconds since the last time step, use it to simulate at a consistent speed Returns dict : updated game state attributes Server Server(self, game_state_store:pygase.backend.GameStateStore) Listen to clients and orchestrate the flow of events and state updates. The Server instance does not contain game logic or state, it is only responsible for connections to clients. The state is provided by a GameStateStore and game logic by a GameStateMachine . Arguments game_state_store (GameStateStore) : part of the backend that provides an interface to the pygase.GameState Attributes connections (list) : contains each clients address as a key leading to the corresponding pygase.connection.ServerConnection instance host_client (tuple) : address of the host client (who has permission to shutdown the server), if there is any game_state_store (GameStateStore) : game state repository Members hostname (str) : read-only access to the servers hostname port (int) : read-only access to the servers port number hostname Get the hostname or IP address on which the server listens. Returns None when the server is not running. port Get the port number on which the server listens. Returns None when the server is not running. run Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -> None Start the server under a specified address. This is a blocking function but can also be spawned as a coroutine or in a thread via Server.run_in_thread() . Arguments port (int) : port number the server will be bound to, default will be an available port chosen by the computers network controller hostname (str) : hostname or IP address the server will be bound to. Defaults to 'localhost' . event_wire (GameStateMachine) : object to which events are to be repeated (has to implement a _push_event(event) method and is typically a GameStateMachine ) run_in_thread Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -> threading.Thread Start the server in a seperate thread. See Server.run() . Returns threading.Thread : the thread the server loop runs in shutdown Server.shutdown(self) -> None Shut down the server. The server can be restarted via Server.run() in which case it will remember previous connections. This method can also be spawned as a coroutine. dispatch_event Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -> None Send an event to one or all clients. Arguments event_type (str) : identifies the event and links it to a handler target_client (tuple, str) : either 'all' for an event broadcast, or a clients address as a tuple retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be executed after the event was received and be passed a reference to the corresponding pygase.connection.ServerConnection instance Additional positional and keyword arguments will be sent as event data and passed to the clients handler function. register_event_handler Server.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for received events of the given type get_available_ip_addresses get_available_ip_addresses() -> list Return a list of all locally available IPv4 addresses.","title":"API"},{"location":"api/main/#pygase","text":"Create smooth and scalable online and LAN multiplayer games easily. PyGaSe, or Python Game Server, is a library (or framework, whichever term you prefer) that provides a complete set of high-level components for real-time networking for games. As a user of this library you will only need classes and functions directly imported from pygase : # For clients: from pygase import Client # For backends: from pygase import GameState, GameStateStore, GameStateMachine, Server # Not necessary but might come in handy: from pygase import get_availabe_ip_addresses","title":"pygase"},{"location":"api/main/#gamestate","text":"GameState(self, time_order:int=0, game_status:int=0, **kwargs) Customize a serializable game state model. Contains game state information that will be synchronized between the server and the clients. Via pygase.utils.Sendable its instances will be serialized using the msgpack protocol and must only contain attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. Arguments time_order () : current time order number of the game state, higher means more recent game_status () : GameStatus enum value that describes whether or not the game loop is running Provide custom game state attributes via keyword arguments or assign them later. Attributes game_status () time_order () GameState instances mainly consist of custom attributes that make up the game state.","title":"GameState"},{"location":"api/main/#is_paused","text":"GameState.is_paused(self) -> bool Return True if game is paused.","title":"is_paused"},{"location":"api/main/#backend","text":"Backend(self, initial_game_state:pygase.gamestate.GameState, time_step_function, event_handlers:dict=None) Easily create a fully integrated PyGaSe backend. Arguments initial_game_state (GameState) : state of the game before the simulation begins time_step_function (callable) : function that takes a game state and a time difference and returns a dict of updated game state attributes (see GameStateMachine.time_step() ) event_handlers (dict) : a dict with event types as keys and event handler functions as values Attributes game_state_store (GameStateStore) : the backends game state repository game_state_machine (GameStateMachine) : logic component that runs the game loop server (Server) : handles connections to PyGaSe clients Example # Run a game loop that continuously increments `foo` with velocity `bar`. Backend( initial_gamestate=GameState(foo=0.0, bar=0.5), time_step_function=lambda game_state, dt: {foo: game_state.foo + game_state.bar*dt}, # Handle client events to reset `foo` and set a new `bar` value. event_handlers={ \"RESET_FOO\": lambda game_state, dt: {foo: 0.0}, \"SET_BAR\": lambda new_bar, game_state, dt: {bar: new_bar} } ).run(hostname=\"localhost\", port=8080)","title":"Backend"},{"location":"api/main/#run","text":"Backend.run(self, hostname:str, port:int) Run state machine and server and bind the server to a given address. Arguments hostname (str) : hostname or IPv4 address the server will be bound to port (int) : port number the server will be bound to","title":"run"},{"location":"api/main/#shutdown","text":"Backend.shutdown(self) Shut down server and stop game loop.","title":"shutdown"},{"location":"api/main/#gamestatestore","text":"GameStateStore(self, initial_game_state:pygase.gamestate.GameState=None) Provide access to a game state and manage state updates. Arguments inital_game_state (GameState) : state of the game before the simulation begins Raises TypeError : if 'initial_game_state' is not an instance of GameState","title":"GameStateStore"},{"location":"api/main/#get_update_cache","text":"GameStateStore.get_update_cache(self) -> list Return the latest state updates.","title":"get_update_cache"},{"location":"api/main/#get_game_state","text":"GameStateStore.get_game_state(self) -> pygase.gamestate.GameState Return the current game state.","title":"get_game_state"},{"location":"api/main/#push_update","text":"GameStateStore.push_update(self, update:pygase.gamestate.GameStateUpdate) -> None Push a new state update to the update cache. This method will usually be called by whatever is progressing the game state, usually a GameStateMachine .","title":"push_update"},{"location":"api/main/#gamestatemachine","text":"GameStateMachine(self, game_state_store:pygase.backend.GameStateStore) Run a simulation that propagates the game state. A GameStateMachine progresses a game state through time, applying all game simulation logic. This class is meant either as a base class from which you inherit and implement the GameStateMachine.time_step() method, or you assign an implementation after instantiation. Arguments game_state_store (GameStateStore) : part of the PyGaSe backend that provides the state Attributes game_time (float) : duration the game has been running in seconds","title":"GameStateMachine"},{"location":"api/main/#register_event_handler","text":"GameStateMachine.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. For event handlers to have any effect, the events have to be wired from a Server to the GameStateMachine via the event_wire argument of the Server.run() method. Arguments event_type (str) : which type of event to link the handler function to handler_func (callable, coroutine) : function or coroutine to be invoked for events of the given type In addition to the event data, a GameStateMachine #s handler function gets passed - the following keyword arguments : - - game_state : game state at the time of the event - - dt : time since the last time step - - client_address : client which sent the event that is being handled It is expected to return an update dict like the time_step method.","title":"register_event_handler"},{"location":"api/main/#run_game_loop","text":"GameStateMachine.run_game_loop(self, interval:float=0.02) -> None Simulate the game world. This function blocks as it continously progresses the game state through time but it can also be spawned as a coroutine or in a thread via Server.run_game_loop_in_thread() . As long as the simulation is running, the game_state.status will be GameStatus.get('Active') . Arguments interval (float) : (minimum) duration in seconds between consecutive time steps","title":"run_game_loop"},{"location":"api/main/#run_game_loop_in_thread","text":"GameStateMachine.run_game_loop_in_thread(self, interval:float=0.02) -> threading.Thread Simulate the game in a seperate thread. See GameStateMachine.run_game_loop() . Returns threading.Thread : the thread the game loop runs in","title":"run_game_loop_in_thread"},{"location":"api/main/#stop","text":"GameStateMachine.stop(self, timeout:float=1.0) -> bool Pause the game simulation. This sets self.status to Gamestatus.get('Paused') . This method can also be spawned as a coroutine. A subsequent call of GameStateMachine.run_game_loop() will resume the simulation at the point where it was stopped. Arguments timeout (float) : time in seconds to wait for the simulation to stop Returns bool : wether or not the simulation was successfully stopped","title":"stop"},{"location":"api/main/#time_step","text":"GameStateMachine.time_step(self, game_state:pygase.gamestate.GameState, dt:float) -> dict Calculate a game state update. This method should be implemented to return a dict with all the updated state attributes. Arguments game_state (GameState) : the state of the game prior to the time step dt (float) : time in seconds since the last time step, use it to simulate at a consistent speed Returns dict : updated game state attributes","title":"time_step"},{"location":"api/main/#server","text":"Server(self, game_state_store:pygase.backend.GameStateStore) Listen to clients and orchestrate the flow of events and state updates. The Server instance does not contain game logic or state, it is only responsible for connections to clients. The state is provided by a GameStateStore and game logic by a GameStateMachine . Arguments game_state_store (GameStateStore) : part of the backend that provides an interface to the pygase.GameState Attributes connections (list) : contains each clients address as a key leading to the corresponding pygase.connection.ServerConnection instance host_client (tuple) : address of the host client (who has permission to shutdown the server), if there is any game_state_store (GameStateStore) : game state repository Members hostname (str) : read-only access to the servers hostname port (int) : read-only access to the servers port number","title":"Server"},{"location":"api/main/#hostname","text":"Get the hostname or IP address on which the server listens. Returns None when the server is not running.","title":"hostname"},{"location":"api/main/#port","text":"Get the port number on which the server listens. Returns None when the server is not running.","title":"port"},{"location":"api/main/#run_1","text":"Server.run(self, port:int=0, hostname:str='localhost', event_wire=None) -> None Start the server under a specified address. This is a blocking function but can also be spawned as a coroutine or in a thread via Server.run_in_thread() . Arguments port (int) : port number the server will be bound to, default will be an available port chosen by the computers network controller hostname (str) : hostname or IP address the server will be bound to. Defaults to 'localhost' . event_wire (GameStateMachine) : object to which events are to be repeated (has to implement a _push_event(event) method and is typically a GameStateMachine )","title":"run"},{"location":"api/main/#run_in_thread","text":"Server.run_in_thread(self, port:int=0, hostname:str='localhost', event_wire=None, daemon=True) -> threading.Thread Start the server in a seperate thread. See Server.run() . Returns threading.Thread : the thread the server loop runs in","title":"run_in_thread"},{"location":"api/main/#shutdown_1","text":"Server.shutdown(self) -> None Shut down the server. The server can be restarted via Server.run() in which case it will remember previous connections. This method can also be spawned as a coroutine.","title":"shutdown"},{"location":"api/main/#dispatch_event","text":"Server.dispatch_event(self, event_type:str, *args, target_client='all', retries:int=0, ack_callback=None, **kwargs) -> None Send an event to one or all clients. Arguments event_type (str) : identifies the event and links it to a handler target_client (tuple, str) : either 'all' for an event broadcast, or a clients address as a tuple retries (int) : number of times the event is to be resent in case it times out ack_callback (callable, coroutine) : will be executed after the event was received and be passed a reference to the corresponding pygase.connection.ServerConnection instance Additional positional and keyword arguments will be sent as event data and passed to the clients handler function.","title":"dispatch_event"},{"location":"api/main/#register_event_handler_1","text":"Server.register_event_handler(self, event_type:str, event_handler_function) -> None Register an event handler for a specific event type. Arguments event_type (str) : event type to link the handler function to handler_func (callable, coroutine) : will be called for received events of the given type","title":"register_event_handler"},{"location":"api/main/#get_available_ip_addresses","text":"get_available_ip_addresses() -> list Return a list of all locally available IPv4 addresses.","title":"get_available_ip_addresses"},{"location":"api/utils/","text":"pygase.utils Use helpful classes and functions. Provides utilities used in PyGaSe code or helpful to users of this library. Contents Comparable : mixin that makes object compare as equal if their type and attributes match Sendable : mixin that allows to serialize objects to small bytestrings NamedEnum : base class for lists of strings to be mapped to integer values Sqn : subclass of int for sequence numbers that always fit in 2 bytes LockedRessource : class that attaches a threading.Lock to a ressource get_available_ip_addresses : function that returns a list of local network interfaces Comparable Comparable(self, /, *args, **kwargs) Compare objects by equality of attributes. Sendable Sendable(self, /, *args, **kwargs) Send objects via UDP packages. This mixin for classes that are supposed to be sendable as part of a PyGaSe package makes objects serializable with the msgpack protocol. Sendables can only have attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such. to_bytes Sendable.to_bytes(self) -> bytes Serialize the object to a compact bytestring. from_bytes Sendable.from_bytes(bytepack:bytes) Deserialize a bytestring into an instance of this class. Arguments bytepack () : the bytestring to be parsed to a subclass of Sendable Returns a copy of an object that was serialized via Sendable.to_bytes NamedEnum NamedEnum(self, /, *args, **kwargs) Map string labels to integer values. This is a base class meant to be subclassed to produce a dynamic enum mapping type. Example class MyEnum(NamedEnum): '''Encode labels in integers. - \"foo\" - \"bar\" ''' MyEnum.register(\"foo\") MyEnum.register(\"bar\") assert MyEnum.get(\"foo\") == 1 assert MyEnum.get(\"bar\") == 2 assert MyEnum.get(1) == \"foo\" assert MyEnum.get(2) == \"bar\" get NamedEnum.get(name_or_value) Get the value for a label or vice versa. Arguments name_or_value () : label or value to de- or encode Returns int value for given string label or vice versa Raises TypeError : if argument is neither int nor str register NamedEnum.register(name:str) -> None Add a new label to the mapping. Arguments name () : string label to register as new enum value Sqn Sqn(self, /, *args, **kwargs) Use finite periodic integers that fit in 2 bytes. Subclass of int that provides a residue-class-like behaviour of wrapping back to 1 after a maximum value. Use it to represent sequence numbers with a fixed number of bytes when you only need well-defined ordering within a specific finite scale. 0 represents the state before the sequence has started. For the default bytesize of 2 the maximum sequence number is 65535. set_bytesize Sqn.set_bytesize(bytesize:int) -> None Redefine the bytesize and wrap-over behaviour for all Sqn instances. Arguments bytesize () : new size for the bytes representation of Sqn instances get_max_sequence Sqn.get_max_sequence() -> int Return the maximum sequence number after which Sqn s wrap back to 1. to_sqn_bytes Sqn.to_sqn_bytes(self) -> bytes Return representation of the number in exactly the currenly set bytesize. The default bytesize is 2. from_sqn_bytes Sqn.from_sqn_bytes(bytestring:bytes) -> 'Sqn' Return Sqn object that was encoded in given bytestring. LockedRessource LockedRessource(self, ressource) Access a ressource thread-safely. This class makes an object available via a context manager that essentialy attaches a threading.Lock to it, that threads writing to this object should abide. Usage example: myRessource = { 'foo': 'bar' } myLockedRessource = LockedRessource(myRessource) with myLockedRessource() as ressource: # do stuff without any other threads meddling with the ressource Arguments ressource () : object to be wrapped Attributes lock () : threading.Lock that threads writing to ressource should abide. ressource () get_available_ip_addresses get_available_ip_addresses() -> list Return a list of all locally available IPv4 addresses.","title":"pygase.utils"},{"location":"api/utils/#pygaseutils","text":"Use helpful classes and functions. Provides utilities used in PyGaSe code or helpful to users of this library.","title":"pygase.utils"},{"location":"api/utils/#contents","text":"Comparable : mixin that makes object compare as equal if their type and attributes match Sendable : mixin that allows to serialize objects to small bytestrings NamedEnum : base class for lists of strings to be mapped to integer values Sqn : subclass of int for sequence numbers that always fit in 2 bytes LockedRessource : class that attaches a threading.Lock to a ressource get_available_ip_addresses : function that returns a list of local network interfaces","title":"Contents"},{"location":"api/utils/#comparable","text":"Comparable(self, /, *args, **kwargs) Compare objects by equality of attributes.","title":"Comparable"},{"location":"api/utils/#sendable","text":"Sendable(self, /, *args, **kwargs) Send objects via UDP packages. This mixin for classes that are supposed to be sendable as part of a PyGaSe package makes objects serializable with the msgpack protocol. Sendables can only have attributes of type str , bytes , Sqn , int , float , bool as well as list s or tuple s of such.","title":"Sendable"},{"location":"api/utils/#to_bytes","text":"Sendable.to_bytes(self) -> bytes Serialize the object to a compact bytestring.","title":"to_bytes"},{"location":"api/utils/#from_bytes","text":"Sendable.from_bytes(bytepack:bytes) Deserialize a bytestring into an instance of this class. Arguments bytepack () : the bytestring to be parsed to a subclass of Sendable Returns a copy of an object that was serialized via Sendable.to_bytes","title":"from_bytes"},{"location":"api/utils/#namedenum","text":"NamedEnum(self, /, *args, **kwargs) Map string labels to integer values. This is a base class meant to be subclassed to produce a dynamic enum mapping type. Example class MyEnum(NamedEnum): '''Encode labels in integers. - \"foo\" - \"bar\" ''' MyEnum.register(\"foo\") MyEnum.register(\"bar\") assert MyEnum.get(\"foo\") == 1 assert MyEnum.get(\"bar\") == 2 assert MyEnum.get(1) == \"foo\" assert MyEnum.get(2) == \"bar\"","title":"NamedEnum"},{"location":"api/utils/#get","text":"NamedEnum.get(name_or_value) Get the value for a label or vice versa. Arguments name_or_value () : label or value to de- or encode Returns int value for given string label or vice versa Raises TypeError : if argument is neither int nor str","title":"get"},{"location":"api/utils/#register","text":"NamedEnum.register(name:str) -> None Add a new label to the mapping. Arguments name () : string label to register as new enum value","title":"register"},{"location":"api/utils/#sqn","text":"Sqn(self, /, *args, **kwargs) Use finite periodic integers that fit in 2 bytes. Subclass of int that provides a residue-class-like behaviour of wrapping back to 1 after a maximum value. Use it to represent sequence numbers with a fixed number of bytes when you only need well-defined ordering within a specific finite scale. 0 represents the state before the sequence has started. For the default bytesize of 2 the maximum sequence number is 65535.","title":"Sqn"},{"location":"api/utils/#set_bytesize","text":"Sqn.set_bytesize(bytesize:int) -> None Redefine the bytesize and wrap-over behaviour for all Sqn instances. Arguments bytesize () : new size for the bytes representation of Sqn instances","title":"set_bytesize"},{"location":"api/utils/#get_max_sequence","text":"Sqn.get_max_sequence() -> int Return the maximum sequence number after which Sqn s wrap back to 1.","title":"get_max_sequence"},{"location":"api/utils/#to_sqn_bytes","text":"Sqn.to_sqn_bytes(self) -> bytes Return representation of the number in exactly the currenly set bytesize. The default bytesize is 2.","title":"to_sqn_bytes"},{"location":"api/utils/#from_sqn_bytes","text":"Sqn.from_sqn_bytes(bytestring:bytes) -> 'Sqn' Return Sqn object that was encoded in given bytestring.","title":"from_sqn_bytes"},{"location":"api/utils/#lockedressource","text":"LockedRessource(self, ressource) Access a ressource thread-safely. This class makes an object available via a context manager that essentialy attaches a threading.Lock to it, that threads writing to this object should abide. Usage example: myRessource = { 'foo': 'bar' } myLockedRessource = LockedRessource(myRessource) with myLockedRessource() as ressource: # do stuff without any other threads meddling with the ressource Arguments ressource () : object to be wrapped Attributes lock () : threading.Lock that threads writing to ressource should abide. ressource ()","title":"LockedRessource"},{"location":"api/utils/#get_available_ip_addresses","text":"get_available_ip_addresses() -> list Return a list of all locally available IPv4 addresses.","title":"get_available_ip_addresses"}]}